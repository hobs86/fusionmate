var ooVooClient = function (ooVooClient, undefined) { "use strict"; function log(e) { console.log(e) } function ajaxGet(e, t, n, o) { var r = _privates._urls.setHttpUrl + "1.0/" + e + "?t=" + t + "&ct=1&cst=2&sv=1.8&cv=0.2"; ajax("GET", !1, r, null, o) } function ajaxPost(e, t, n, o) { var r = _privates._urls.setHttpUrl + "1.0/" + e + "?t=" + t + "&ct=1&cst=2&sv=1.8&cv=0.2"; ajax("POST", !1, r, n, o) } function ajax(e, t, n, o, r) { var i = new XMLHttpRequest; return "withCredentials" in i ? i.open(e, n, t) : "undefined" != typeof XDomainRequest ? (i = new XDomainRequest, i.open(e, n, t)) : i = null, i ? ("post" == e.toLowerCase() && (i.setRequestHeader("Access-Control-Allow-Origin", "*"), i.setRequestHeader("Content-Type", "application/json"), i.setRequestHeader("Accept", "application/json")), null !== window.navigator.userAgent.match("Firefox") && i.setRequestHeader("Accept", "application/json"), i.onload = function () { onSuccess({ data: { responseText: i.responseText }, func: r }) }, i.onerror = function () { return onError(ooVooClient.CustomeError.XHR_Failed, "XHR failed", r) }, null != o ? i.send(JSON.stringify(o)) : i.send(), i) : onError(ooVooClient.CustomeError.CORS_NotSupported, "", r) } function _getBaseUrl() { var e = _privates._urls.sandboxBaseURL; return _privates._isSandbox || (e = _privates._urls.prodBaseURL), e } function _appLogin(e, t, n, o) { _privates._isSandbox = t === !1 ? !1 : !0; var r = _getBaseUrl() + "1.0/sso/app/login/client?user_id=" + e + "&at=" + n + "&ct=1&cst=2&sv=1.8&cv=0.2&redirect_to=" + o; location.href = r } function _getConfig(e) { var t = _privates._urls.prodBaseURL + "1.0/webconfig?t=" + _privates._userToken + "&ct=1&cst=2&sv=1.8&cv=0.2"; ajax("GET", !1, t, "{}", function (t) { return null == t || null == t.responseText ? onError({ code: -1, msg: "Invalid answer from ooVoo Config.", func: e }) : (t = JSON.parse(t.responseText), t && t.meta && null != t.meta.code ? t.meta.code < 0 ? onError({ code: t.meta.code, msg: "Error validating config request.", func: e }) : onSuccess({ func: e, data: t.payload }) : onError({ code: -1, msg: "Invalid answer from connect Api Config.", func: e })) }) } function checkCapabilities() { return window.mozRTCPeerConnection || window.webkitRTCPeerConnection || window.RTCPeerConnection ? !0 : !1 } function onError(e, t, n) { return !n && e.func && (n = e.func), "function" == typeof n ? (t && "" != t.trim() && (e.msg += " " + t), e.timestamp = (new Date).getTime(), n({ error: e })) : void 0 } function onServerError(e, t, n) { if ("function" == typeof n) { var o = { code: e, msg: "The Remote server returned an error.", timestamp: (new Date).getTime() }; return onError(o, t, n) } } function onSuccess(e) { if (null != e.func) { var t = {}; return null != e.data && (t = e.data), t.timestamp = (new Date).getTime(), e.func(t) } } function _connect(e, t) { return checkCapabilities() ? e ? e.userToken ? e.enableMesagging && e.enableMesagging === !0 && !e.userId ? onError(ooVooClient.CustomeError.Missing_Argument, "missing user id", t) : (_privates._userToken = e.userToken, _privates._userId = e.userId, void _getConfig(function (n) { if (!n || n.error) { var o = n.error.code ? n.error : ooVooClient.CustomeError.Unspecified_Error; return onError(o, "The remote server returned error. Please check this error code.", t) } _privates._urls.getHttpUrl = n.hosts.get_http_host, _privates._urls.setHttpUrl = n.hosts.set_http_host, _privates._urls.socketUrl = n.hosts.websocket_host, _privates._urls.socketUrlSecure = n.hosts.websocket_host_secure, _privates._socket.timeOut = 1e3 * n.params.websocket_keepalive_sec, ooVooClient.Push = new Push, e.enableMesagging && e.enableMesagging === !0 && (ooVooClient.Messaging = new Messaging(e.userId, e.userToken)), t() })) : onError(ooVooClient.CustomeError.Missing_Argument, "missing user token", t) : onError(ooVooClient.CustomeError.Missing_Argument, "missing app config object", t) : onError(ooVooClient.CustomeError.Browser_Is_Not_Supported, "", t) } var _privates = { _userId: "", _userToken: "", _isSandbox: !1, _urls: { sandboxBaseURL: "https://connect.sandbox.oovoo.com/", prodBaseURL: "https://connect.oovoo.com/", getHttpUrl: "", setHttpUrl: "", socketUrl: "", socketUrlSecure: "" }, _socket: { interValFunc: null, ws: null, timeOut: 6e4 }, _static: { keepAliveMsg: '{"payload": {"type": "ping"}}' } }, sdkVersion = "2.1.0.0", erizoUsername = "", erizoRole = "presenter", erizoType = "oovoo", gateway_ip = "", remoteStreams = {}, localAudioIsMuted = !1, remoteAudioIsMuted = !1, localVideoIsStopped = !1, remoteVideoIsStopped = !1, ConferenceStateEvent = function () { var e = function (e) { this.type = e }; return e.prototype = { type: null }, e }(), VideoStateEvent = function () { var e = function (e, t) { this.stream = e, this.uid = remoteStreams[e.stream.getId()].user.name, this.state = t }; return e.prototype = { stream: null, uid: null, state: null }, e }(), AVChat = function () { function e(e, t) { if (null == l || null == p) return onError(ooVooClient.CustomeError.Operation_Failed, "You must call init before setConfig", t); if (e === undefined || null == e) d = !1, u = !1; else { if (e.videoResolution && "string" != typeof e.videoResolution) return onError(ooVooClient.CustomeError.Invalid_Argument, "Argument videoResolution is not supported. Please use ooVooClient.VideoResolution enum.", t); if (e.videoFrameRate) { if (isNaN(e.videoFrameRate[0]) || isNaN(e.videoFrameRate[1])) return onError(ooVooClient.CustomeError.Invalid_Argument, "Argument videoFrameRate is not a number 5-30.", t); e.videoFrameRate[0] < 5 ? e.videoFrameRate[0] = 5 : e.videoFrameRate[1] > 30 && (e.videoFrameRate[1] = 30) } d = e.videoResolution, u = e.videoFrameRate } onSuccess({ func: t }) } function t(e) { return null == d || null == u ? (onError(ooVooClient.CustomeError.Operation_Failed, "Conference.setConfig was not called.", e), !1) : !0 } function n(e, t, n, o, i, a) { var d = !1, l = !1; "string" == typeof a && (a = a.toLowerCase(), l = h[a] || l); var p = n || location.hostname; "" === p && (p = location.hostname); var m = "https:" === window.location.protocol; p += m ? ":443" : ":80", s = Erizo.Client({ username: erizoUsername, role: erizoRole, host: p, type: erizoType, secure: m }), c = Erizo.Stream({ audio: !0, video: l, data: !0, screen: d, attributes: { resolution: a } }), c.setVideo(a, u), s.on("client-connected", function (n) { log("Gateway connected, Trying logging on avs"); var n = new ConferenceStateEvent(ooVooClient.ConferenceStateType.CONNECTED); onConferenceStateChanged(n), y(e, t, _privates._userToken, o, i, function (e) { s.send(e, function (e) { log("Session Info: " + (e || "UNKNOWN")) }) }) }), s.on("client-id", function (e) { "string" == typeof s.ClientId && "" !== s.ClientId && (f.remoteId = s.ClientId, log("My Client Id: " + s.ClientId)); var e = new ConferenceStateEvent(ooVooClient.ConferenceStateType.JOINED); e.uid = f.userId, onConferenceStateChanged(e), s.publish(c, {}) }), s.on("client-disconnected", function (e) { log("Gateway disconnected"), f = { userId: "", remoteId: "" }, c.close(), c = null, s = null; var e = new ConferenceStateEvent(ooVooClient.ConferenceStateType.DISCONNECTED); onConferenceStateChanged(e) }), s.onMessage(function (e) { log("Message Received: " + e.attr); var t = null; try { t = JSON.parse(e.attr) } catch (n) { } if (t && "158" == t.id) { var o = remoteStreams[t.SourceID].user.name; t.SourceID = o; var i = f.userId; t.TargetID = i, ooVooClient.AVChat.onReceiveData(JSON.stringify(t)) } t && "136" == t.id && r(t) }), s.on("stream-published", function (e) { var t = e.stream; log("Stream published: " + t.getId()); var t = e.stream, n = t.getId(); log("Stream subscribed. Stream Id: " + n); var o = new ConferenceStateEvent(ooVooClient.ConferenceStateType.JOINED); o.stream = t.stream, o.uid = _privates._userId, o.user_data = "", ooVooClient.AVChat.onParticipantJoined(o) }), s.on("stream-subscribed", function (e) { var t = e.stream, n = t.getId(); log("Stream subscribed. Stream Id: " + n); var o = new ConferenceStateEvent(ooVooClient.ConferenceStateType.JOINED); o.stream = t.stream, o.uid = remoteStreams[n].user.name, o.user_data = remoteStreams[n].user.info, ooVooClient.AVChat.onParticipantJoined(o) }), s.on("stream-added", function (e) { var t = e.stream; remoteStreams[t.getId()].stream = t, log("Stream added. Stream Id: " + t.getId()), s.subscribe(t) }), s.on("stream-removed", function (e) { var t = e.stream, n = remoteStreams[t.getId()].user.name; delete remoteStreams[t.getId()], log("Stream removed. Stream Id: " + t.getId()); var o = new ConferenceStateEvent(ooVooClient.ConferenceStateType.DISCONNECTED); o.uid = n, ooVooClient.AVChat.onParticipantLeft(o) }), s.on("client-joined", function (e) { remoteStreams[e.user.userId] = { user: e.user, stream: null }, log("Client joined: " + e.user) }), s.on("client-left", function (e) { log("Client left: " + e.user) }), s.on("video-ready", function (e) { log("Video In On: " + e.stream.getId()); var t = new VideoStateEvent(e, ooVooClient.VideoStateType.PLAY); onRemoteVideoStateChanged(t) }), s.on("video-hold", function (e) { log("Video In Off: " + e.stream.getId()); var t = new VideoStateEvent(e, ooVooClient.VideoStateType.STOPPED); onRemoteVideoStateChanged(t) }), s.on("video-on", function (e) { log("Video Out On: " + e.stream.getId()) }), s.on("video-off", function (e) { log("Video Out Off: " + e.stream.getId()) }), s.on("audio-ready", function (e) { log("Audio In On: " + e.stream.getId()) }), s.on("audio-hold", function (e) { log("Audio In Off: " + e.stream.getId()) }), s.on("audio-on", function (e) { log("Audio Out On: " + e.stream.getId()) }), s.on("audio-off", function (e) { log("Audio Out Off: " + e.stream.getId()) }), c.on("access-accepted", function () { log("access-accepted"), s.connect(), localAudioIsMuted ? c.pauseAudio() : c.playAudio(), localVideoIsStopped ? c.pauseVideo() : c.playVideo(); var e = new ConferenceStateEvent(ooVooClient.ConferenceStateType.ACCESS_ACCEPTED); e.stream = c.stream, e.uid = c.getId(), onConferenceStateChanged(e) }), c.on("access-denied", function (e) { if (log("Video/Audio access denied"), "DevicesNotFoundError" == e.msg || "Starting audio failed" == e.msg) { var t = new ConferenceStateEvent(ooVooClient.ConferenceStateType.DEVICE_NOT_FOUND); onConferenceStateChanged(t) } else if ("TrackStartError" == e.msg || "ConstraintNotSatisfiedError" == e.msg) { var t = new ConferenceStateEvent(ooVooClient.ConferenceStateType.CAM_RES_NOT_SUPPORTED); onConferenceStateChanged(t) } else { var t = new ConferenceStateEvent(ooVooClient.ConferenceStateType.ACCESS_DENIED); onConferenceStateChanged(t) } }), c.init() } function o(e, t, n, o) { var r = { payload: { id: "158", SourceID: e, TargetID: t, Buffer: n }, type: "message" }; o(r) } function r(e) { if (e && e.Msg) { var t = e.Msg.split(":"); if (t && t.length > 0) { var n = parseInt(t[0], 16); if (10 == n) { var o = parseInt(t[2], 16).toString(), r = parseInt(t[3], 16), i = 1 == parseInt(t[4], 16), s = { uid: remoteStreams[o].user.name, deg: r, mrr: i }; ooVooClient.AVChat.onVideoRotate(s) } } } } function i(e) { for (var t in remoteStreams) if (remoteStreams[t].user.name == e) return t } var s, a = function () { }, c = null, d = null, u = null, l = null, p = null, f = { userId: "", remoteId: "" }, m = "", h = function () { function e(e, t, n, o) { return { mandatory: { minWidth: e, minHeight: n, maxWidth: t, maxHeight: o }, optional: [] } } return { unspecified: !0, sif: e(320, 320, 240, 240), vga: e(640, 640, 480, 480), hd720p: e(1280, 1280, 720, 720) } }(), g = function () { var e = navigator.userAgent.toLowerCase(); return e.indexOf("windows phone") > -1 ? "Windows Phone" : e.indexOf("windows") > -1 ? "Windows" : e.indexOf("cros") > -1 ? "CrOS" : e.indexOf("android") > -1 ? "Android" : e.indexOf("iphone") > -1 || e.indexOf("ipad") > -1 || e.indexOf("ipod") > -1 ? "iOs" : e.indexOf("mac") > -1 ? "Mac" : "" }(), v = function () { var e, t, n = navigator.userAgent; return -1 != (t = n.indexOf("Opera")) ? "Opera" : -1 != (t = n.indexOf("Chrome")) ? "GoogleChrome" : -1 != (t = n.indexOf("Safari")) ? "Safari" : -1 != (t = n.indexOf("Firefox")) ? "Firefox" : -1 != (t = n.indexOf("MSIE")) || "Netscape" == navigator.appName ? "InternetExplorer" : (e = n.lastIndexOf(" ") + 1) < (t = n.lastIndexOf("/")) ? n.substring(e, t) : "" }(), y = function (e, t, n, o, r, i) { f.userId = o; var s = { payload: { avs_ip: m, avs_port: "443", app_id: n, app_token: n, Carrier: "", ClientSubType: "", ClientType: "10", DeviceModel: "", Manufacturer: "", ParticipantInfo: r, Conference_ID: e, conf_key: t, Os: g, Browser: v, ParticipantID: o, SdkVersion: sdkVersion, CodecInfo: "vc=vp8;r=all;dv=0;ac=g711,opus" }, type: "login" }; i(s) }; return a.prototype = { onParticipantJoined: function (e) { }, onParticipantLeft: function (e) { }, onConferenceStateChanged: function (e) { }, onRemoteVideoStateChanged: function (e) { }, onVideoRotate: function (e) { }, onReceiveData: function (e) { }, init: function (t, n) { return null != ooVooClient.session_token ? ("function" == typeof t ? (n = t, t = { audio: !0, video: !0 }) : (null == t && (t = {}), (null == t.audio || 0 != t.audio) && (t.audio = !0), null == t.video || 0 != t.video ? t.video = !0 : (t.videoResolution = ooVooClient.VideoResolution.HIGH, t.videoFrameRate = new Array(5, 15))), 0 == t.audio && 1 == t.video ? (onError(ooVooClient.CustomeError.Operation_Failed, "video only is not supported", n), ooVooClient.AVChat) : (l = t.audio, localAudioIsMuted = !t.audio, p = t.video, localVideoIsStopped = !t.video, setTimeout(function () { onSuccess({ func: n }) }, 0), e({ videoResolution: t.videoResolution, videoFrameRate: t.videoFrameRate }), this)) : void onError(ooVooClient.CustomeError.Operation_Failed, "You must call ooVooClient.init before Conference.init", n) }, join: function (e, o, r, i) { if (t(i)) { if (null == e || "" == e.trim()) return onError(ooVooClient.CustomeError.Missing_Argument, "Argument conferenceId is missing.", i); if (null != c) return onError(ooVooClient.CustomeError.Already_In_Call, "userId : " + o, i); ajaxPost("avs/webrtccall", _privates._userToken, { payload: { conf_id: e } }, function (t) { if (null == t || null == t.responseText) return onServerError(-2e4, "The remote server returned error. Please check this error code.", i); if (t = JSON.parse(t.responseText), t && t.meta && null != t.meta.code) { if (t.meta.code < 0) return onServerError(t.meta.code, "The remote server returned error. Please check this error code.", i); log("got avs ip: " + t.payload.avs_ip + " gate way ip: " + t.payload.gw_ip + " conference key: " + t.payload.conf_key), m = t.payload.avs_ip, gateway_ip = t.payload.gw_ip; var s = t.payload.conf_key; return n(e, s, gateway_ip, o, r, d), onSuccess({ data: t.payload, func: i }) } return onError(ooVooClient.CustomeError.Unspecified_Error, "The remote server returned error. Please check this error code.", i) }) } }, AudioController: { setRecorderMute: function (e) { return 1 != e && (e = !1), localAudioIsMuted = e, localAudioIsMuted ? c.pauseAudio() : c.playAudio(), onSuccess({ data: { isMuted: localAudioIsMuted }, func: function () { } }) }, isRecorderMuted: function () { return localAudioIsMuted }, setPlaybackMute: function (e) { if (1 != e && (e = !1), remoteAudioIsMuted = e, s.remoteStreams) for (var t in remoteStreams) e ? s.remoteStreams[remoteStreams[t].stream.getId()].pauseAudio() : s.remoteStreams[remoteStreams[t].stream.getId()].playAudio(); return onSuccess({ data: { isMuted: remoteAudioIsMuted }, func: function () { } }) }, isPlaybackMuted: function () { return remoteAudioIsMuted } }, VideoController: { stopTransmit: function () { localVideoIsStopped || (localVideoIsStopped = !0, c.pauseVideo()) }, startTransmit: function () { localVideoIsStopped && (localVideoIsStopped = !1, c.playVideo()) }, isTransmitted: function () { var e = c && c.stream && c.stream.getVideoTracks && c.stream.getVideoTracks().length > 0; return e && !localVideoIsStopped }, registerRemote: function (e) { if (null == e) return onError(ooVooClient.CustomeError.Missing_Argument, "Argument userId is missing.", callbackFunc); remoteVideoIsStopped = !0; var t = i(e); s.remoteStreams && s.remoteStreams[t] && s.remoteStreams[t].playVideo() }, unRegisterRemote: function (e) { if (null == e) return onError(ooVooClient.CustomeError.Missing_Argument, "Argument userId is missing.", callbackFunc); remoteVideoIsStopped = !0; var t = i(e); s.remoteStreams && s.remoteStreams[t] && s.remoteStreams[t].pauseVideo() } }, sendData: function (e, t, n) { if (null == t || "" == t.trim()) return onError(ooVooClient.CustomeError.Missing_Argument, "Argument data is missing.", n); var r = f.remoteId, a = i(e); o(r, a, t, function (e) { s.send(e, n, n) }) }, leave: function () { s.disconnect(), localAudioIsMuted = !1, localVideoIsStopped = !1, remoteAudioIsMuted = !1 } }, a }(), Messaging = function () { function _sendAcknowledgeMsg(e, t, n) { var o = ackObj; o.hdr.attr2 = t, o.hdr.attr3 = n; var r = _urlEncode(_escapeJson(JSON.stringify(o))); _sendMessage(r, e, function (e) { log("send Acknowledge: " + JSON.stringify(e)) }) } function _sendText(e, t, n) { var o = txtObj, r = _b64EncodeUnicode(e); o.body = r; var i = _urlEncode(_escapeJson(JSON.stringify(o))); _sendMessage(i, t, n) } function _escapeJson(e) { for (var t = "", n = 0; n < e.length; n++) switch (e[n]) { case '"': t += '\\"'; break; case "/": t += "\\/"; break; case "\b": t += "\\b"; break; case "\f": t += "\\f"; break; case "\n": t += "\\n"; break; case "\r": t += "\\r"; break; case "	": t += "\\t"; break; case "\\": t += "\\\\"; break; default: t += e[n] } return t } function _unEscapeJson(e) { for (var t = "UNESCAPED", n = "", o = 0; o < e.length; o++) switch (t) { case "ESCAPED": switch (e[o]) { case '"': n += '"'; break; case "/": n += "/"; break; case "b": n += "\b"; break; case "f": n += "\f"; break; case "n": n += "\n"; break; case "r": n += "\r"; break; case "t": n += "	"; break; case "\\": n += "\\"; break; default: n += e[o] } t = "UNESCAPED"; break; case "UNESCAPED": switch (e[o]) { case "\\": t = "ESCAPED"; break; default: n += e[o] } } return n } function _urlEncode(e) { return encodeURIComponent(e) } function _urlDecode(e) { return decodeURIComponent(e) } function _b64EncodeUnicode(e) { return window.btoa(unescape(encodeURIComponent(e))) } function _b64DecodeUnicode(e) { return decodeURIComponent(escape(window.atob(e))) } function _sendMessage(e, t, n) { _isSocketOpen() || _webSocketManagerConnect(_privates._userId, _privates._userToken); var o = { payload: { msg_to: t, msg_body: e } }; ajaxPost("im/3p/msg/broadcast", _privates._userToken, o, function (e) { return null == e || null == e.responseText ? onServerError(-2e4, "The remote server returned error. Please check this error code.", n) : (e = JSON.parse(e.responseText), e && e.meta && null != e.meta.code ? e.meta.code < 0 ? onServerError(e.meta.code, "The remote server returned error. Please check this error code.", n) : onSuccess({ data: e.payload, func: function (e) { return onSuccess({ data: e.payload, func: function () { n({ result: "0" }) } }) } }) : onError(ooVooClient.CustomeError.Unspecified_Error, "The remote server returned error. Please check this error code.", n)) }) } function _connectToNotificationService(e, t, n) { return _isSocketOpen() ? onSuccess({ func: n }) : (_webSocketManagerConnect(e, t), onSuccess({ func: n })) } function _webSocketManagerConnect(UserName, TokenSocket) { TokenSocket = decodeURIComponent(TokenSocket); var connectMessage = '{\n "payload": {\n "type": "' + enMsgType.AUTH_REQUEST + '",\n  "user": "' + UserName + '",  "token": "' + TokenSocket + '"}}', isSecureConnection = "https:" === window.location.protocol; return "WebSocket" in window ? (isSecureConnection ? _privates._socket.ws = new WebSocket(_privates._urls.socketUrlSecure) : _privates._socket.ws = new WebSocket(_privates._urls.socketUrl), _privates._socket.ws.onopen = function () { log(isSecureConnection ? "open socket to " + _privates._urls.socketUrlSecure : "open socket to " + _privates._urls.socketUrl), _requestKeepAlive(_privates._socket.timeOut); try { _privates._socket.ws.send(connectMessage) } catch (e) { log(JSON.stringify(e)) } log("WebSocketManager.Connect: webSocket.send message:" + connectMessage) }, _privates._socket.ws.onmessage = function (evt) { var msg = eval("(" + evt.data + ")"), received_msg = msg.payload ? msg.payload : msg, msgType = received_msg.msg_type; switch (msgType) { case enMsgType.PRENSE_SUBSCRIBE: case enMsgType.PRENSE_SUBSCRIBED: case enMsgType.PRENSE_UNSUBSCRIBE: case enMsgType.PRENSE_UNSUBSCRIBED: case enMsgType.PRESENCE_AVAILABLE: case enMsgType.PRESENCE_AWAY: case enMsgType.PRESENCE_BUSY: case enMsgType.PRESENCE_INVISIBLE: case enMsgType.PRESENCE_UNAVAILABLE: case enMsgType.MSG_CHAT: case enMsgType.MSG_GROUPCHAT: case enMsgType.MSG_SPECIAL: case enMsgType.MSG_NOTIFICATION: default: if (received_msg.msg_from && received_msg.msg_body) { var msg = JSON.parse(_unEscapeJson(_urlDecode(received_msg.msg_body))), body = _b64DecodeUnicode(msg.body); body && "" != body || msg.hdr.attr1 != msgBodyType.Acknowledge ? ooVooClient.Messaging.onReciveMessage({ from: received_msg.msg_from, body: body, msg_id: received_msg.msg_id }) : ooVooClient.Messaging.onReciveAcknowledgement({ from: received_msg.msg_from, msg_id: received_msg.msg_id, state: msg.hdr.attr3 }) } } log(JSON.stringify(received_msg)), window.clearInterval(_privates._socket.interValFunc), _requestKeepAlive(_privates._socket.timeOut) }, _privates._socket.ws.onclose = function () { log("WebSocketManager.Connect: onClose - websocket is closed. trying to reconnect.") }, _privates._socket.ws.onerror = function (e) { return ooVoo.onError({ code: -1, msg: "web socket error." }) }, void 0) : ooVoo.onError({ code: -1, msg: "WebSocket NOT supported by this Browser" }) } function _requestKeepAlive(e) { _privates._socket.interValFunc = setInterval(function () { _privates._socket.ws != undefined && (1 == _privates._socket.ws.readyState ? (_privates._socket.ws.send(_privates._static.keepAliveMsg), log("requestKeepAlive: send request message:" + _privates._static.keepAliveMsg + " evrey:" + _privates._socket.timeOut)) : window.clearInterval(_privates._socket.interValFunc)) }, e) } function _closeWebSocketConnection(e) { _privates._socket.ws != undefined && 1 == _privates._socket.ws.readyState && _privates._socket.ws.close() } function _isSocketOpen() { return _privates && _privates._socket.ws && 1 == _privates._socket.ws.readyState } var msgBodyType = { Acknowledge: "ack", Text: "user" }, txtObj = { hdr: { attr1: msgBodyType.Text }, body: "" }, ackObj = { hdr: { attr1: msgBodyType.Acknowledge, attr2: "", attr3: "" }, body: "" }, Messaging = function (e, t) { _connectToNotificationService(e, t, function (e) { log("connecting to message service") }) }, enMsgType = { AUTH_REQUEST: "auth.request", AUTH_RESPONSE: "auth.response", PRENSE_SUBSCRIBE: "presence.subscribe", PRENSE_SUBSCRIBED: "presence.subscribed", PRENSE_UNSUBSCRIBE: "presence.unsubscribe", PRENSE_UNSUBSCRIBED: "presence.unsubscribed", PRESENCE_AVAILABLE: "presence.available", PRESENCE_BUSY: "presence.busy", PRESENCE_AWAY: "presence.away", PRESENCE_INVISIBLE: "presence.invisible", PRESENCE_UNAVAILABLE: "presence.unavailable", MSG_CHAT: "message.chat", MSG_GROUPCHAT: "message.groupchat", MSG_NOTIFICATION: "message.notification", MSG_SPECIAL: "message.special", SET_BIND: "iq.set.bind", SET_PRIVATE_PREFS: "iq.set.private.prefs" }; return Messaging.prototype = { onReciveMessage: function (e) { }, onReciveAcknowledgement: function (e) { }, send: function (e, t) { return e ? e.to && Array.isArray(e.to) ? e.body ? void _sendText(e.body, e.to, t) : onError(ooVooClient.CustomeError.Missing_Argument, "missing message body", t) : onError(ooVooClient.CustomeError.Missing_Argument, "missing user id", t) : onError(ooVooClient.CustomeError.Missing_Argument, "missing params", t) }, sendAcknowledgement: function (e, t) { return e ? e.to && Array.isArray(e.to) ? e.msg_id ? e.state ? void _sendAcknowledgeMsg(e.to, e.msg_id, e.state, t) : onError(ooVooClient.CustomeError.Missing_Argument, "missing message state", t) : onError(ooVooClient.CustomeError.Missing_Argument, "missing message id", t) : onError(ooVooClient.CustomeError.Missing_Argument, "missing user id", t) : onError(ooVooClient.CustomeError.Missing_Argument, "missing params", t) }, AcknowledgeState: { Delivered: "Delivered", Read: "Read" } }, Messaging }(), Push = function () { function e(e, t, n, o) { var r = { payload: { msg_to: t, msg_body: e, msg_property: n } }; ajaxPost("pns/3p/msg/send", _privates._userToken, r, function (e) { return null == e || null == e.responseText ? onServerError(-2e4, "The remote server returned error. Please check this error code.", o) : (e = JSON.parse(e.responseText), e && e.meta && null != e.meta.code ? e.meta.code < 0 ? onServerError(e.meta.code, "The remote server returned error. Please check this error code.", o) : onSuccess({ data: e.payload, func: function (e) { var t = { result: "0" }; o(t) } }) : onError(ooVooClient.CustomeError.Unspecified_Error, "The remote server returned error. Please check this error code.", o)) }) } var t = function () { }; return t.prototype = { send: function (t, n) { if (!t) return onError(ooVooClient.CustomeError.Missing_Argument, "missing params", n); if (!t.to || !Array.isArray(t.to)) return onError(ooVooClient.CustomeError.Missing_Argument, "missing user id", n); if (!t.body) return onError(ooVooClient.CustomeError.Missing_Argument, "missing message body", n); var o = t.property ? t.property : ""; e(t.body, t.to, o, n) } }, t }(); return ooVooClient = { VideoResolution: { NORMAL: "sif", HIGH: "vga", HD: "hd720p" }, ConferenceStateType: { ACCESS_DENIED: 0, ACCESS_ACCEPTED: 1, CONNECTED: 2, JOINED: 3, DISCONNECTED: 4, RECONNECTING: 5, RECONNECTED: 6, DEVICE_NOT_FOUND: 7, CAM_RES_NOT_SUPPORTED: 8 }, VideoStateType: { PLAY: 0, STOPPED: 1, PAUDED: 2 }, CustomeError: { Unspecified_Error: { code: -2e4, type: "Unspecified_Error", msg: "The application encountered an unexpected condition.", timestamp: (new Date).getTime() }, CORS_NotSupported: { code: -35002, type: "Authorization_Failed", msg: "CORS not supported.", timestamp: (new Date).getTime() }, XHR_Failed: { code: -35003, type: "Authorization_Failed", msg: "XMLHttpRequest failed or XDomainRequest (for IE) failed.", timestamp: (new Date).getTime() }, Operation_Failed: { code: -6e4, type: "Operation_Failed", msg: "Operation Failed.", timestamp: (new Date).getTime() }, Browser_Is_Not_Supported: { code: -60001, type: "Operation_Failed", msg: "Browser is not support WebRTC.", timestamp: (new Date).getTime() }, Already_In_Call: { code: -60002, type: "Operation_Failed", msg: "The user is already in call.", timestamp: (new Date).getTime() }, Missing_Argument: { code: -60003, type: "Operation_Failed", msg: "Missing Argument.", timestamp: (new Date).getTime() }, Invalid_Argument: { code: -60004, type: "Operation_Failed", msg: "Invalid Argument.", timestamp: (new Date).getTime() } }, app_id: "", session_token: "", connect: function (e, t) { _connect(e, t) }, authorization: function (e) { _appLogin(e.userId, e.isSandbox, e.token, e.callbackUrl) }, AVChat: new AVChat, Messaging: null, Push: null } }(window.ooVooClient = window.ooVooClient || {}); if (function (e) {
var t = function () { "use strict"; var e = {}; return Object.defineProperties(e, { version: { get: function () { return "0.0.5" } }, name: { get: function () { return "Intel WebRTC SDK" } } }), e }(), n = {}; n.Base64 = function () { "use strict"; var e, t, n, o, r, i, s, a, c, d, u, l; for (e = -1, t = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"], n = [], i = 0; i < t.length; i += 1) n[t[i]] = i; return s = function (e) { o = e, r = 0 }, a = function () { var t; return o ? r >= o.length ? e : (t = 255 & o.charCodeAt(r), r += 1, t) : e }, c = function (n) { var o, r, i, c; for (s(n), o = "", r = new Array(3), i = 0, c = !1; !c && (r[0] = a()) !== e;) r[1] = a(), r[2] = a(), o += t[r[0] >> 2], r[1] !== e ? (o += t[r[0] << 4 & 48 | r[1] >> 4], r[2] !== e ? (o += t[r[1] << 2 & 60 | r[2] >> 6], o += t[63 & r[2]]) : (o += t[r[1] << 2 & 60], o += "=", c = !0)) : (o += t[r[0] << 4 & 48], o += "=", o += "=", c = !0), i += 4, i >= 76 && (o += "\n", i = 0); return o }, d = function () { if (!o) return e; for (; ;) { if (r >= o.length) return e; var t = o.charAt(r); if (r += 1, n[t]) return n[t]; if ("A" === t) return 0 } }, u = function (e) { return e = e.toString(16), 1 === e.length && (e = "0" + e), e = "%" + e, unescape(e) }, l = function (t) { var n, o, r; for (s(t), n = "", o = new Array(4), r = !1; !r && (o[0] = d()) !== e && (o[1] = d()) !== e;) o[2] = d(), o[3] = d(), n += u(o[0] << 2 & 255 | o[1] >> 4), o[2] !== e ? (n += u(o[1] << 4 & 255 | o[2] >> 2), o[3] !== e ? n += u(o[2] << 6 & 255 | o[3]) : r = !0) : r = !0; return n }, { encodeBase64: c, decodeBase64: l } }(), n.Logger = function () { "use strict"; var e, t, n, o, r, i, s, a = 0, c = 1, d = 2, u = 3, l = 4, p = 5, f = a; return e = function (e) { e > p ? e = p : a > e && (e = a), f = e }, t = function () { var e = arguments[0], t = arguments; if (!(f > e)) { switch (e) { case a: t[0] = "DEBUG:"; break; case c: t[0] = "TRACE:"; break; case d: t[0] = "INFO:"; break; case u: t[0] = "WARNING:"; break; case l: t[0] = "ERROR:"; break; default: return } console.log.apply(console, t) } }, n = function () { for (var e = [a], n = 0; n < arguments.length; n++) e.push(arguments[n]); t.apply(this, e) }, o = function () { for (var e = [c], n = 0; n < arguments.length; n++) e.push(arguments[n]); t.apply(this, e) }, r = function () { for (var e = [d], n = 0; n < arguments.length; n++) e.push(arguments[n]); t.apply(this, e) }, i = function () { for (var e = [u], n = 0; n < arguments.length; n++) e.push(arguments[n]); t.apply(this, e) }, s = function () { for (var e = [l], n = 0; n < arguments.length; n++) e.push(arguments[n]); t.apply(this, e) }, { DEBUG: a, TRACE: c, INFO: d, WARNING: u, ERROR: l, NONE: p, setLogLevel: e, log: t, debug: n, trace: o, info: r, warning: i, error: s } }(), t.sessionId = 103, t.Connection = function (o) { "use strict"; var r = {}; if (o.session_id = t.sessionId += 1, "undefined" != typeof module && module.exports) n.Logger.error("Publish/subscribe video/audio streams not supported in erizofc yet"), r = t.FcStack(o); else if (null !== e.navigator.userAgent.match("Firefox")) r.browser = "mozilla", r = t.FirefoxStack(o); else if (e.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35) n.Logger.debug("Stable!"), r = t.ChromeStableStack(o), r.browser = "chrome-stable"; else { if (!(e.navigator.userAgent.toLowerCase().indexOf("chrome") >= 0)) throw r.browser = "none", "WebRTC stack not available"; n.Logger.debug("Canary!"), r = t.ChromeCanaryStack(o), r.browser = "chrome-canary" } return r }, t.GetUserMedia = function (e, t, o) { "use strict"; navigator.getMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia, "undefined" != typeof module && module.exports ? n.Logger.error("Video/audio streams not supported in erizofc yet") : navigator.getMedia(e, t, o) }, t.EventDispatcher = function (e) { "use strict"; var t = {}; return e.dispatcher = {}, e.dispatcher.eventListeners = {}, t.addEventListener = function (t, n) { void 0 === e.dispatcher.eventListeners[t] && (e.dispatcher.eventListeners[t] = []), e.dispatcher.eventListeners[t].push(n) }, t.on = t.addEventListener, t.removeEventListener = function (t, n) { var o; o = e.dispatcher.eventListeners[t].indexOf(n), -1 !== o && e.dispatcher.eventListeners[t].splice(o, 1) }, t.dispatchEvent = function (t) { var o; n.Logger.debug("Event: " + t.type); for (o in e.dispatcher.eventListeners[t.type]) e.dispatcher.eventListeners[t.type].hasOwnProperty(o) && e.dispatcher.eventListeners[t.type][o](t) }, t }, t.LicodeEvent = function (e) { "use strict"; var t = {}; return t.type = e.type, t }, t.StreamEvent = function (e) { "use strict"; var n = t.LicodeEvent(e); return n.stream = e.stream, n.msg = e.msg, n }, t.ClientEvent = function (e) { "use strict"; var n = t.LicodeEvent(e); return n.user = e.user, n.attr = e.attr, n.streams = e.streams, n }, t.PublisherEvent = function (e) { "use strict"; var n = t.LicodeEvent(e); return n }, t.Client = function (e) {
"use strict"; function o(e) { var t = e.stream; t.pc && "function" == typeof t.signalOnPlayAudio ? u.dispatchEvent(e) : t.pc && "closed" !== t.pc.state ? setTimeout(function () { o(e) }, 20) : n.Logger.warning("event missed:", e) } function r() { var e = arguments[0]; if ("function" == typeof e) { var t = Array.prototype.slice.call(arguments, 1); e.apply(null, t) } } function i(e, t) { return { type: "control", payload: { action: e, streamId: t } } } var s, a, c, d, u = t.EventDispatcher(e), l = 0, p = 1, f = 2; return u.remoteStreams = {}, u.localStreams = {}, u.socket = void 0, u.state = l, u.ClientId = "", u.addEventListener("client-disconnected", function () { var e, o, r; u.state = l, u.ClientId = ""; for (e in u.remoteStreams) u.remoteStreams.hasOwnProperty(e) && (o = u.remoteStreams[e], d(o), delete u.remoteStreams[e], r = t.StreamEvent({ type: "stream-removed", stream: o }), u.dispatchEvent(r)); u.remoteStreams = {}; for (e in u.localStreams) u.localStreams.hasOwnProperty(e) && (o = u.localStreams[e], o.pc.close(), delete u.localStreams[e]); try { u.socket.disconnect() } catch (i) { n.Logger.debug("Socket already disconnected") } }), d = function (e) { void 0 !== e.stream && (e.pc.close(), e.local && e.stream.stop()) }, s = function (e, r, i) {
var s = e.secure === !0, c = e.host; s ? delete io.sockets["https://" + c] : delete io.sockets["http://" + c], void 0 !== u.socket ? u.socket.socket.connect() : (u.socket = io.connect(c, { reconnect: !1, secure: s }), u.socket.on("onAddStream", function (e) { var n, o = t.Stream({ streamID: e.id, local: !1, audio: e.audio, video: e.video, screen: e.screen, attributes: e.attributes }); u.remoteStreams[e.id] = o, n = t.StreamEvent({ type: "stream-added", stream: o }), u.dispatchEvent(n) }), u.socket.on("onRemoveStream", function (e) { var n, o = u.remoteStreams[e.id]; delete u.remoteStreams[e.id], d(o), n = t.StreamEvent({ type: "stream-removed", stream: o }), u.dispatchEvent(n) }), u.socket.on("onPublishStream", function (e) { n.Logger.info("Stream published"); var o = u.localStreams[e.id], r = t.StreamEvent({ type: "stream-published", stream: o }); u.dispatchEvent(r) }), u.socket.on("onVideoHold", function (e) { var r = u.remoteStreams[e.id]; if (r) { var i = t.StreamEvent({ type: "video-hold", stream: r }); o(i) } else n.Logger.debug("Stream does not exist:", e.id) }), u.socket.on("onVideoReady", function (e) { var n = u.remoteStreams[e.id]; if (n) { var r = t.StreamEvent({ type: "video-ready", stream: n }); o(r) } }), u.socket.on("onAudioHold", function (e) { var r = u.remoteStreams[e.id]; if (r) { var i = t.StreamEvent({ type: "audio-hold", stream: r }); o(i) } else n.Logger.debug("Stream does not exist:", e.id) }), u.socket.on("onAudioReady", function (e) { var n = u.remoteStreams[e.id]; if (n) { var r = t.StreamEvent({ type: "audio-ready", stream: n }); o(r) } }), u.socket.on("onAllAudioHold", function () { for (var e in u.remoteStreams) if (u.remoteStreams.hasOwnProperty(e)) { var n = u.remoteStreams[e], o = t.StreamEvent({ type: "audio-hold", stream: n }); u.dispatchEvent(o) } }), u.socket.on("onAllAudioReady", function () { for (var e in u.remoteStreams) if (u.remoteStreams.hasOwnProperty(e)) { var n = u.remoteStreams[e], o = t.StreamEvent({ type: "audio-ready", stream: n }); u.dispatchEvent(o) } }), u.socket.on("onVideoOn", function (e) { var n = u.localStreams[e.id]; if (n) { var o = t.StreamEvent({ type: "video-on", stream: n }); u.dispatchEvent(o) } }), u.socket.on("onVideoOff", function (e) { var n = u.localStreams[e.id]; if (n) { var o = t.StreamEvent({ type: "video-off", stream: n }); u.dispatchEvent(o) } }), u.socket.on("onAudioOn", function (e) {
var n = u.localStreams[e.id]; if (n) { var o = t.StreamEvent({ type: "audio-on", stream: n }); u.dispatchEvent(o) }
}), u.socket.on("onAudioOff", function (e) { var n = u.localStreams[e.id]; if (n) { var o = t.StreamEvent({ type: "audio-off", stream: n }); u.dispatchEvent(o) } }), u.socket.on("disconnect", function () { if (n.Logger.info("Socket disconnected"), u.state !== l) { var e = t.ClientEvent({ type: "client-disconnected" }); u.dispatchEvent(e) } }), u.socket.on("onClientJoin", function (e) { var n = t.ClientEvent({ type: "client-joined", attr: e.attr, user: e.user }); u.dispatchEvent(n) }), u.socket.on("onClientLeave", function (e) { var n = t.ClientEvent({ type: "client-left", attr: e.attr, user: e.user }); u.dispatchEvent(n) }), u.socket.on("onClientId", function (e) { u.ClientId = e; var n = t.ClientEvent({ type: "client-id", attr: e }); u.dispatchEvent(n) }), u.socket.on("onCustomMessage", function (e) { var n = t.ClientEvent({ type: "message-received", attr: e.msg }); u.dispatchEvent(n) }), u.socket.on("connect_failed", function (e) { i(e || "connection_failed") }), u.socket.on("error", function (e) { i(e || "connection_error") })), a("token", e, r, i)
}, a = function (e, t, o, i) { if (void 0 === u.socket) return void r(i, "socket error"); try { u.socket.emit(e, t, function (e, t) { "success" === e ? "function" == typeof o && o(t) : "function" == typeof i && i(t) }) } catch (s) { n.Logger.error("Error in sendMessageSocket():", s) } }, c = function (e, t, o, r) { if (void 0 === u.socket) return void n.Logger.error("Error in sendSDPSocket(): socket not ready"); try { u.socket.emit(e, t, o, function (e, t) { void 0 !== r && r(e, t) }) } catch (i) { n.Logger.error("Error in sendSDPSocket():", i) } }, u.connect = function (o) { if (u.state !== l) return n.Logger.error("Gateway already connecting/connected"), void r(o, u.state); var i = e; u.state = p, s(i, function (o) { u.stunServerUrl = o.stunServerUrl, u.turnServer = o.turnServer, u.state = f, e.defaultVideoBW = o.defaultVideoBW, e.maxVideoBW = o.maxVideoBW, n.Logger.info("Gateway connected."); var r = t.ClientEvent({ type: "client-connected" }); u.dispatchEvent(r) }, function (e) { n.Logger.error("Not Connected! Error: " + e), r(o, e) }) }, u.disconnect = function () { var e = t.ClientEvent({ type: "client-disconnected" }); u.dispatchEvent(e) }, u.publish = function (o, s) { if ("object" != typeof o || null === o) return void r(s, "stream is invalid"); if (("object" != typeof o.stream || null === o.stream) && void 0 === o.url) return void r(s, "stream access not ready"); var a = o.getAttributes() || {}; a.maxVideoBW = a.maxVideoBW || e.defaultVideoBW, a.maxVideoBW > e.maxVideoBW && (a.maxVideoBW = e.maxVideoBW), o.local && void 0 === u.localStreams[o.getId()] && (o.hasAudio() || o.hasVideo() || o.hasScreen()) && (void 0 !== o.url ? c("publish", { state: "url", audio: o.hasAudio(), video: o.hasVideo(), attributes: o.getAttributes() }, o.url, function (e, t) { "success" === e ? (n.Logger.info("Stream published"), o.getId = function () { return t }, u.localStreams[t] = o, o.onClose = function () { u.unpublish(o) }) : (n.Logger.info("Error when publishing the stream", e), r(s, e)) }) : (o.pc = t.Connection({ callback: function (e) { c("publish", { state: "offer", audio: o.hasAudio(), video: o.hasVideo(), attributes: o.getAttributes() }, e, function (e, t) { return "error" === e ? void r(s, e) : (o.pc.onsignalingmessage = function (e) { o.pc.onsignalingmessage = function () { }, c("publish", { state: "ok", audio: o.hasAudio(), video: o.hasVideo(), screen: o.hasScreen(), attributes: o.getAttributes() }, e), o.getId = function () { return t.id }, u.localStreams[t.id] = o, o.onClose = function () { u.unpublish(o) }, o.signalOnPlayAudio = function (e, t) { u.send(i("audio-out-on"), e, t) }, o.signalOnPauseAudio = function (e, t) { u.send(i("audio-out-off"), e, t) }, o.signalOnPlayVideo = function (e, t) { u.send(i("video-out-on"), e, t) }, o.signalOnPauseVideo = function (e, t) { u.send(i("video-out-off"), e, t) } }, void o.pc.processSignalingMessage(e)) }) }, stunServerUrl: u.stunServerUrl, turnServer: u.turnServer, maxAudioBW: a.maxAudioBW, maxVideoBW: a.maxVideoBW }), o.pc.addStream(o.stream))) }, u.unpublish = function (e, t) { return "object" != typeof e || null === e ? void r(t, "stream is invalid") : void (e.local && void 0 !== u.localStreams[e.getId()] ? (a("unpublish", e.getId(), function () { }, t), (e.hasAudio() || e.hasVideo() || e.hasScreen()) && void 0 === e.url && (e.pc.close(), e.pc = void 0), delete u.localStreams[e.getId()], e.getId = function () { return null }, e.onClose = void 0, e.signalOnPlayAudio = void 0, e.signalOnPauseAudio = void 0, e.signalOnPlayVideo = void 0, e.signalOnPauseVideo = void 0) : r(t, "stream is not local")) }, u.subscribe = function (e, o) { return "object" != typeof e || null === e ? void r(o, "stream is invalid") : void (e.local ? r(o, "stream is local") : e.hasVideo() || e.hasAudio() || e.hasScreen() ? (e.pc = t.Connection({ callback: function (t) { c("subscribe", { streamId: e.getId(), audio: e.hasAudio(), video: e.hasVideo() }, t, function (t) { return "error" === t ? void r(o, t) : void e.pc.processSignalingMessage(t) }) }, nop2p: !0, audio: e.hasAudio(), video: e.hasVideo(), stunServerUrl: u.stunServerUrl, turnServer: u.turnServer }), e.pc.onaddstream = function (o) { n.Logger.info("Stream subscribed"), e.stream = o.stream; var r = t.StreamEvent({ type: "stream-subscribed", stream: e }); u.dispatchEvent(r), e.signalOnPlayAudio = function (t, n) { u.send(i("audio-in-on", e.getId()), t, n) }, e.signalOnPauseAudio = function (t, n) { u.send(i("audio-in-off", e.getId()), t, n) }, e.signalOnPlayVideo = function (t, n) { u.send(i("video-in-on", e.getId()), t, n) }, e.signalOnPauseVideo = function (t, n) { u.send(i("video-in-off", e.getId()), t, n) } }, n.Logger.info("Subscribing to: " + e.getId())) : r(o, "stream does not has video/audio/screen")) }, u.unsubscribe = function (e, t) { return "object" != typeof e || null === e ? void r(t, "stream is invalid") : void (void 0 !== u.socket ? e.local || a("unsubscribe", e.getId(), function (n) { return "error" === n ? void r(t, n) : (d(e), e.signalOnPlayAudio = void 0, e.signalOnPauseAudio = void 0, e.signalOnPlayVideo = void 0, void (e.signalOnPauseVideo = void 0)) }, function (e) { n.Logger.error("Error calling unsubscribe."), r(t, e) }) : r(t, "socket error")) }, u.onMessage = function (e) { return "function" != typeof e ? void n.Logger.error("onMessage:", "callback is not a function") : void u.on("message-received", e) }, u.send = function (e, t, n) { a("customMessage", e, t, n) }, u.getStreamsByAttribute = function (e, t) { var n, o, r = []; for (n in u.remoteStreams) u.remoteStreams.hasOwnProperty(n) && (o = u.remoteStreams[n], void 0 !== o.getAttributes() && void 0 !== o.getAttributes()[e] && o.getAttributes()[e] === t && r.push(o)); return r }, u
}, t.Stream = function (o) { "use strict"; function r(e, t, n, o) { return { mandatory: { minWidth: e, minHeight: n, maxWidth: t, maxHeight: o }, optional: [] } } function i() { return null !== e.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && e.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35 } var s = t.EventDispatcher(o); if (s.stream = o.stream, s.url = o.url, s.onClose = void 0, s.local = !1, s.video = o.video, s.audio = o.audio, s.screen = o.screen, s.videoSize = o.videoSize, !(void 0 === s.videoSize || s.videoSize instanceof Array && 4 === s.videoSize.length)) throw Error("Invalid Video Size"); (void 0 === o.local || o.local === !0) && (s.local = !0), s.initialized = !s.local; var a = { "true": !0, unspecified: !0, sif: r(320, 320, 240, 240), vga: r(640, 640, 480, 480), hd720p: r(1280, 1280, 720, 720) }; return s.signalOnPlayAudio = void 0, s.signalOnPauseAudio = void 0, s.signalOnPlayVideo = void 0, s.signalOnPauseVideo = void 0, s.getId = function () { return o.streamID }, s.getAttributes = function () { return o.attributes }, s.hasAudio = function () { return o.audio }, s.hasVideo = function () { return o.video }, s.hasScreen = function () { return o.screen }, s.setVideo = function (e, t) { return e += "", void 0 !== a[e] ? (s.video = o.video = a[e], o.attributes = o.attributes || {}, o.attributes.resolution = e, "object" == typeof t && t instanceof Array && t.length > 1 && (o.attributes.minFrameRate = t[0], o.attributes.maxFrameRate = t[1]), o.attributes.maxVideoBW = 512, "vga" == e ? o.attributes.maxVideoBW = 1024 : "hd720p" == e && (o.attributes.maxVideoBW = 2048), !0) : !1 }, s.setAudio = function (e) { return e === !0 || e === !1 ? (s.audio = o.audio = e, !0) : !1 }, s.init = function () { if (s.initialized === !0) return void n.Logger.debug("Stream is already initialized"); if (s.local !== !0) return void n.Logger.debug("Stream is not local"); try { if ((o.audio || o.video || o.screen) && void 0 === o.url) { n.Logger.debug("Requested access to local media"); var e = o.video; e === !0 && void 0 !== s.videoSize && (e = { mandatory: { minWidth: s.videoSize[0], minHeight: s.videoSize[1], maxWidth: s.videoSize[2], maxHeight: s.videoSize[3] } }); var r = { video: e, audio: o.audio, fake: o.fake }; o.screen && (r = { video: { mandatory: { chromeMediaSource: "screen", maxWidth: screen.availWidth, maxHeight: screen.availHeight } } }), !i() && o.attributes.minFrameRate && (r.video === !0 && (r.video = { mandatory: {} }), r.video.mandatory.maxFrameRate = o.attributes.maxFrameRate, r.video.mandatory.minFrameRate = o.attributes.minFrameRate), n.Logger.debug(r), t.GetUserMedia(r, function (e) { n.Logger.info("User has granted access to local media."), s.stream = e; var o = t.StreamEvent({ type: "access-accepted" }); s.dispatchEvent(o) }, function (e) { var o = e.name ? e.name : e; n.Logger.error("Failed to get access to local media. Error code was " + o + "."); var r = t.StreamEvent({ type: "access-denied", msg: o }); s.dispatchEvent(r) }) } else { var a = t.StreamEvent({ type: "access-accepted" }); s.dispatchEvent(a) } s.initialized = !0 } catch (c) { n.Logger.error("Error accessing to local media", c) } }, s.close = function () { s.initialized === !0 && s.local === !0 && ("function" == typeof s.onClose && s.onClose(), void 0 !== s.stream && void 0 !== s.stream.stop && s.stream.stop(), s.stream = void 0, s.initialized = !1) }, s.enableAudio = function () { return s.hasAudio() && s.initialized && void 0 !== s.stream && s.stream.getAudioTracks()[0] && s.stream.getAudioTracks()[0].enabled !== !0 ? (s.stream.getAudioTracks()[0].enabled = !0, !0) : !1 }, s.disableAudio = function () { return s.hasAudio() && s.initialized && void 0 !== s.stream && s.stream.getAudioTracks()[0] && s.stream.getAudioTracks()[0].enabled ? (s.stream.getAudioTracks()[0].enabled = !1, !0) : !1 }, s.enableVideo = function () { return s.hasVideo() && s.initialized && void 0 !== s.stream && s.stream.getVideoTracks()[0] && s.stream.getVideoTracks()[0].enabled !== !0 ? (s.stream.getVideoTracks()[0].enabled = !0, !0) : !1 }, s.disableVideo = function () { return s.hasVideo() && s.initialized && void 0 !== s.stream && s.stream.getVideoTracks()[0] && s.stream.getVideoTracks()[0].enabled ? (s.stream.getVideoTracks()[0].enabled = !1, !0) : !1 }, s.playAudio = function (e, t) { return s.enableAudio() && "function" == typeof s.signalOnPlayAudio ? s.signalOnPlayAudio(e, t) : void ("function" == typeof t && t("unable to call playAudio")) }, s.pauseAudio = function (e, t) { return s.disableAudio() && "function" == typeof s.signalOnPauseAudio ? s.signalOnPauseAudio(e, t) : void ("function" == typeof t && t("unable to call pauseAudio")) }, s.playVideo = function (e, t) { return s.enableVideo() && "function" == typeof s.signalOnPlayVideo ? s.signalOnPlayVideo(e, t) : void ("function" == typeof t && t("unable to call playVideo")) }, s.pauseVideo = function (e, t) { return s.disableVideo() && "function" == typeof s.signalOnPauseVideo ? s.signalOnPauseVideo(e, t) : void ("function" == typeof t && t("unable to call pauseVideo")) }, s }, t.ChromeCanaryStack = function (t) { "use strict"; var o = {}, r = webkitRTCPeerConnection; o.pc_config = { iceServers: [] }, o.con = { optional: [{ DtlsSrtpKeyAgreement: !0 }] }, t.stunServerUrl && o.pc_config.iceServers.push({ url: t.stunServerUrl }), (t.turnServer || {}).url && o.pc_config.iceServers.push({ username: t.turnServer.username, credential: t.turnServer.password, url: t.turnServer.url }), void 0 === t.audio && (t.audio = !0), void 0 === t.video && (t.video = !0), o.mediaConstraints = { mandatory: { OfferToReceiveVideo: t.video, OfferToReceiveAudio: t.audio } }, o.roapSessionId = 103, o.peerConnection = new r(o.pc_config, o.con), o.peerConnection.onicecandidate = function (e) { n.Logger.debug("PeerConnection: ", t.session_id), e.candidate ? o.iceCandidateCount += 1 : (n.Logger.debug("State: " + o.peerConnection.iceGatheringState), void 0 === o.ices && (o.ices = 0), o.ices = o.ices + 1, o.ices >= 1 && o.moreIceComing && (o.moreIceComing = !1, o.markActionNeeded())) }; var i = function (e) { var n, o; return t.maxVideoBW && (n = e.match(/m=video.*\r\n/), o = n[0] + "b=AS:" + t.maxVideoBW + "\r\n", e = e.replace(n[0], o)), t.maxAudioBW && (n = e.match(/m=audio.*\r\n/), o = n[0] + "b=AS:" + t.maxAudioBW + "\r\n", e = e.replace(n[0], o)), e }; return o.processSignalingMessage = function (e) { n.Logger.debug("Activity on conn " + o.sessionId); var t, r = JSON.parse(e); o.incomingMessage = r, "new" === o.state ? "OFFER" === r.messageType ? (t = { sdp: r.sdp, type: "offer" }, o.peerConnection.setRemoteDescription(new RTCSessionDescription(t)), o.state = "offer-received", o.markActionNeeded()) : o.error("Illegal message for this state: " + r.messageType + " in state " + o.state) : "offer-sent" === o.state ? "ANSWER" === r.messageType ? (t = { sdp: r.sdp, type: "answer" }, n.Logger.debug("Received ANSWER: ", t.sdp), t.sdp = i(t.sdp), o.peerConnection.setRemoteDescription(new RTCSessionDescription(t)), o.sendOK(), o.state = "established") : "pr-answer" === r.messageType ? (t = { sdp: r.sdp, type: "pr-answer" }, o.peerConnection.setRemoteDescription(new RTCSessionDescription(t))) : "offer" === r.messageType ? o.error("Not written yet") : o.error("Illegal message for this state: " + r.messageType + " in state " + o.state) : "established" === o.state && ("OFFER" === r.messageType ? (t = { sdp: r.sdp, type: "offer" }, o.peerConnection.setRemoteDescription(new RTCSessionDescription(t)), o.state = "offer-received", o.markActionNeeded()) : o.error("Illegal message for this state: " + r.messageType + " in state " + o.state)) }, o.addStream = function (e) { o.peerConnection.addStream(e), o.markActionNeeded() }, o.removeStream = function () { o.markActionNeeded() }, o.close = function () { o.state = "closed", o.peerConnection.close() }, o.markActionNeeded = function () { o.actionNeeded = !0, o.doLater(function () { o.onstablestate() }) }, o.doLater = function (t) { e.setTimeout(t, 1) }, o.onstablestate = function () { var e; if (o.actionNeeded) { if ("new" === o.state || "established" === o.state) o.peerConnection.createOffer(function (e) { e.sdp = i(e.sdp), n.Logger.debug("Changed", e.sdp); var t = e.sdp; return t !== o.prevOffer ? (o.peerConnection.setLocalDescription(e), o.state = "preparing-offer", void o.markActionNeeded()) : void n.Logger.debug("Not sending a new offer") }, null, o.mediaConstraints); else if ("preparing-offer" === o.state) { if (o.moreIceComing) return; o.prevOffer = o.peerConnection.localDescription.sdp, n.Logger.debug("Sending OFFER: " + o.prevOffer), o.sendMessage("OFFER", o.prevOffer), o.state = "offer-sent" } else if ("offer-received" === o.state) o.peerConnection.createAnswer(function (e) { if (o.peerConnection.setLocalDescription(e), o.state = "offer-received-preparing-answer", o.iceStarted) return void o.markActionNeeded(); var t = new Date; n.Logger.debug(t.getTime() + ": Starting ICE in responder"), o.iceStarted = !0 }, null, o.mediaConstraints); else if ("offer-received-preparing-answer" === o.state) { if (o.moreIceComing) return; e = o.peerConnection.localDescription.sdp, o.sendMessage("ANSWER", e), o.state = "established" } else o.error("Dazed and confused in state " + o.state + ", stopping here"); o.actionNeeded = !1 } }, o.sendOK = function () { o.sendMessage("OK") }, o.sendMessage = function (e, t) { var n = {}; n.messageType = e, n.sdp = t, "OFFER" === e ? (n.offererSessionId = o.sessionId, n.answererSessionId = o.otherSessionId, n.seq = o.sequenceNumber += 1, n.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (n.offererSessionId = o.incomingMessage.offererSessionId, n.answererSessionId = o.sessionId, n.seq = o.incomingMessage.seq), o.onsignalingmessage(JSON.stringify(n)) }, o.error = function (e) { throw "Error in RoapOnJsep: " + e }, o.sessionId = o.roapSessionId += 1, o.sequenceNumber = 0, o.actionNeeded = !1, o.iceStarted = !1, o.moreIceComing = !0, o.iceCandidateCount = 0, o.onsignalingmessage = t.callback, o.peerConnection.onopen = function () { o.onopen && o.onopen() }, o.peerConnection.onaddstream = function (e) { o.onaddstream && o.onaddstream(e) }, o.peerConnection.onremovestream = function (e) { o.onremovestream && o.onremovestream(e) }, o.peerConnection.oniceconnectionstatechange = function (e) { o.oniceconnectionstatechange && o.oniceconnectionstatechange(e.currentTarget.iceConnectionState) }, o.onaddstream = null, o.onremovestream = null, o.state = "new", o.markActionNeeded(), o }, t.ChromeStableStack = function (t) { "use strict"; var o = {}, r = webkitRTCPeerConnection; o.pc_config = { iceServers: [] }, o.con = { optional: [{ DtlsSrtpKeyAgreement: !0 }] }, t.stunServerUrl && o.pc_config.iceServers.push({ url: t.stunServerUrl }), (t.turnServer || {}).url && o.pc_config.iceServers.push({ username: t.turnServer.username, credential: t.turnServer.password, url: t.turnServer.url }), void 0 === t.audio && (t.audio = !0), void 0 === t.video && (t.video = !0), o.mediaConstraints = { mandatory: { OfferToReceiveVideo: t.video, OfferToReceiveAudio: t.audio } }, o.roapSessionId = 103, o.peerConnection = new r(o.pc_config, o.con), o.peerConnection.onicecandidate = function (e) { n.Logger.debug("PeerConnection: ", t.session_id), e.candidate ? o.iceCandidateCount += 1 : (n.Logger.debug("State: " + o.peerConnection.iceGatheringState), void 0 === o.ices && (o.ices = 0), o.ices = o.ices + 1, o.ices >= 1 && o.moreIceComing && (o.moreIceComing = !1, o.markActionNeeded())) }; var i = function (e) { var n, o; return t.maxVideoBW && (n = e.match(/m=video.*\r\n/), o = n[0] + "b=AS:" + t.maxVideoBW + "\r\n", e = e.replace(n[0], o)), t.maxAudioBW && (n = e.match(/m=audio.*\r\n/), o = n[0] + "b=AS:" + t.maxAudioBW + "\r\n", e = e.replace(n[0], o)), e }; return o.processSignalingMessage = function (e) { n.Logger.debug("Activity on conn " + o.sessionId); var t, r = JSON.parse(e); o.incomingMessage = r, "new" === o.state ? "OFFER" === r.messageType ? (t = { sdp: r.sdp, type: "offer" }, o.peerConnection.setRemoteDescription(new RTCSessionDescription(t)), o.state = "offer-received", o.markActionNeeded()) : o.error("Illegal message for this state: " + r.messageType + " in state " + o.state) : "offer-sent" === o.state ? "ANSWER" === r.messageType ? (t = { sdp: r.sdp, type: "answer" }, n.Logger.debug("Received ANSWER: ", t.sdp), t.sdp = i(t.sdp), o.peerConnection.setRemoteDescription(new RTCSessionDescription(t)), o.sendOK(), o.state = "established") : "pr-answer" === r.messageType ? (t = { sdp: r.sdp, type: "pr-answer" }, o.peerConnection.setRemoteDescription(new RTCSessionDescription(t))) : "offer" === r.messageType ? o.error("Not written yet") : o.error("Illegal message for this state: " + r.messageType + " in state " + o.state) : "established" === o.state && ("OFFER" === r.messageType ? (t = { sdp: r.sdp, type: "offer" }, o.peerConnection.setRemoteDescription(new RTCSessionDescription(t)), o.state = "offer-received", o.markActionNeeded()) : o.error("Illegal message for this state: " + r.messageType + " in state " + o.state)) }, o.addStream = function (e) { o.peerConnection.addStream(e), o.markActionNeeded() }, o.removeStream = function () { o.markActionNeeded() }, o.close = function () { o.state = "closed", o.peerConnection.close() }, o.markActionNeeded = function () { o.actionNeeded = !0, o.doLater(function () { o.onstablestate() }) }, o.doLater = function (t) { e.setTimeout(t, 1) }, o.onstablestate = function () { var e; if (o.actionNeeded) { if ("new" === o.state || "established" === o.state) o.peerConnection.createOffer(function (e) { e.sdp = i(e.sdp), n.Logger.debug("Changed", e.sdp); var t = e.sdp; return t !== o.prevOffer ? (o.peerConnection.setLocalDescription(e), o.state = "preparing-offer", void o.markActionNeeded()) : void n.Logger.debug("Not sending a new offer") }, null, o.mediaConstraints); else if ("preparing-offer" === o.state) { if (o.moreIceComing) return; o.prevOffer = o.peerConnection.localDescription.sdp, n.Logger.debug("Sending OFFER: " + o.prevOffer), o.sendMessage("OFFER", o.prevOffer), o.state = "offer-sent" } else if ("offer-received" === o.state) o.peerConnection.createAnswer(function (e) { if (o.peerConnection.setLocalDescription(e), o.state = "offer-received-preparing-answer", o.iceStarted) return void o.markActionNeeded(); var t = new Date; n.Logger.debug(t.getTime() + ": Starting ICE in responder"), o.iceStarted = !0 }, null, o.mediaConstraints); else if ("offer-received-preparing-answer" === o.state) { if (o.moreIceComing) return; e = o.peerConnection.localDescription.sdp, o.sendMessage("ANSWER", e), o.state = "established" } else o.error("Dazed and confused in state " + o.state + ", stopping here"); o.actionNeeded = !1 } }, o.sendOK = function () { o.sendMessage("OK") }, o.sendMessage = function (e, t) { var n = {}; n.messageType = e, n.sdp = t, "OFFER" === e ? (n.offererSessionId = o.sessionId, n.answererSessionId = o.otherSessionId, n.seq = o.sequenceNumber += 1, n.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (n.offererSessionId = o.incomingMessage.offererSessionId, n.answererSessionId = o.sessionId, n.seq = o.incomingMessage.seq), o.onsignalingmessage(JSON.stringify(n)) }, o.error = function (e) { throw "Error in RoapOnJsep: " + e }, o.sessionId = o.roapSessionId += 1, o.sequenceNumber = 0, o.actionNeeded = !1, o.iceStarted = !1, o.moreIceComing = !0, o.iceCandidateCount = 0, o.onsignalingmessage = t.callback, o.peerConnection.onopen = function () { o.onopen && o.onopen() }, o.peerConnection.onaddstream = function (e) { o.onaddstream && o.onaddstream(e) }, o.peerConnection.onremovestream = function (e) { o.onremovestream && o.onremovestream(e) }, o.peerConnection.oniceconnectionstatechange = function (e) { o.oniceconnectionstatechange && o.oniceconnectionstatechange(e.currentTarget.iceConnectionState) }, o.onaddstream = null, o.onremovestream = null, o.state = "new", o.markActionNeeded(), o }, t.FcStack = function () { "use strict"; var e = {}; return e.addStream = function () { }, e }, t.FirefoxStack = function (t) { "use strict"; var o = {}, r = mozRTCPeerConnection, i = mozRTCSessionDescription, s = !1; return o.pc_config = { iceServers: [] }, t.stunServerUrl && o.pc_config.iceServers.push({ url: t.stunServerUrl }), void 0 === t.audio && (t.audio = !0), void 0 === t.video && (t.video = !0), o.mediaConstraints = { optional: [], mandatory: { OfferToReceiveAudio: t.audio, OfferToReceiveVideo: t.video, MozDontOfferDataChannel: !0 } }, o.roapSessionId = 103, o.peerConnection = new r, o.peerConnection.onicecandidate = function (e) { n.Logger.debug("PeerConnection: ", t.session_id), e.candidate ? o.iceCandidateCount += 1 : (n.Logger.debug("State: " + o.peerConnection.iceGatheringState), void 0 === o.ices && (o.ices = 0), o.ices = o.ices + 1, n.Logger.debug(o.ices), o.ices >= 1 && o.moreIceComing && (o.moreIceComing = !1, o.markActionNeeded())) }, n.Logger.debug('Created webkitRTCPeerConnnection with config "' + JSON.stringify(o.pc_config) + '".'), o.processSignalingMessage = function (e) { n.Logger.debug("Activity on conn " + o.sessionId); var t, r = JSON.parse(e); o.incomingMessage = r, "new" === o.state ? "OFFER" === r.messageType ? (t = { sdp: r.sdp, type: "offer" }, o.peerConnection.setRemoteDescription(new i(t)), o.state = "offer-received", o.markActionNeeded()) : o.error("Illegal message for this state: " + r.messageType + " in state " + o.state) : "offer-sent" === o.state ? "ANSWER" === r.messageType ? (r.sdp = r.sdp.replace(/ generation 0/g, ""), r.sdp = r.sdp.replace(/ udp /g, " UDP "), t = { sdp: r.sdp, type: "answer" }, n.Logger.debug("Received ANSWER: ", t.sdp), o.peerConnection.setRemoteDescription(new i(t)), o.sendOK(), o.state = "established") : "pr-answer" === r.messageType ? (t = { sdp: r.sdp, type: "pr-answer" }, o.peerConnection.setRemoteDescription(new i(t))) : "offer" === r.messageType ? o.error("Not written yet") : o.error("Illegal message for this state: " + r.messageType + " in state " + o.state) : "established" === o.state && ("OFFER" === r.messageType ? (t = { sdp: r.sdp, type: "offer" }, o.peerConnection.setRemoteDescription(new i(t)), o.state = "offer-received", o.markActionNeeded()) : o.error("Illegal message for this state: " + r.messageType + " in state " + o.state)) }, o.addStream = function (e) { s = !0, o.peerConnection.addStream(e), o.markActionNeeded() }, o.removeStream = function () { o.markActionNeeded() }, o.close = function () { o.state = "closed", o.peerConnection.close() }, o.markActionNeeded = function () { o.actionNeeded = !0, o.doLater(function () { o.onstablestate() }) }, o.doLater = function (t) { e.setTimeout(t, 1) }, o.onstablestate = function () { var e; if (o.actionNeeded) { if ("new" === o.state || "established" === o.state) { n.Logger.debug("Creating offer"); var t = function () { o.peerConnection.createOffer(function (e) { var t = e.sdp; return n.Logger.debug("Changed", e.sdp), t !== o.prevOffer ? (o.peerConnection.setLocalDescription(e), o.state = "preparing-offer", void o.markActionNeeded()) : void n.Logger.debug("Not sending a new offer") }, function (e) { n.Logger.debug("Ups! Something went wrong ", e) }, o.mediaConstraints) }; s && (o.mediaConstraints = void 0), t() } else if ("preparing-offer" === o.state) { if (o.moreIceComing) return; o.prevOffer = o.peerConnection.localDescription.sdp, n.Logger.debug("Sending OFFER: ", o.prevOffer), o.sendMessage("OFFER", o.prevOffer), o.state = "offer-sent" } else if ("offer-received" === o.state) o.peerConnection.createAnswer(function (e) { if (o.peerConnection.setLocalDescription(e), o.state = "offer-received-preparing-answer", o.iceStarted) return void o.markActionNeeded(); var t = new Date; n.Logger.debug(t.getTime() + ": Starting ICE in responder"), o.iceStarted = !0 }, function () { n.Logger.debug("Ups! Something went wrong") }); else if ("offer-received-preparing-answer" === o.state) { if (o.moreIceComing) return; e = o.peerConnection.localDescription.sdp, o.sendMessage("ANSWER", e), o.state = "established" } else o.error("Dazed and confused in state " + o.state + ", stopping here"); o.actionNeeded = !1 } }, o.sendOK = function () { o.sendMessage("OK") }, o.sendMessage = function (e, t) { var n = {}; n.messageType = e, n.sdp = t, "OFFER" === e ? (n.offererSessionId = o.sessionId, n.answererSessionId = o.otherSessionId, n.seq = o.sequenceNumber += 1, n.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (n.offererSessionId = o.incomingMessage.offererSessionId, n.answererSessionId = o.sessionId, n.seq = o.incomingMessage.seq), o.onsignalingmessage(JSON.stringify(n)) }, o.error = function (e) { throw "Error in RoapOnJsep: " + e }, o.sessionId = o.roapSessionId += 1, o.sequenceNumber = 0, o.actionNeeded = !1, o.iceStarted = !1, o.moreIceComing = !0, o.iceCandidateCount = 0, o.onsignalingmessage = t.callback, o.peerConnection.onopen = function () { o.onopen && o.onopen() }, o.peerConnection.onaddstream = function (e) { o.onaddstream && o.onaddstream(e) }, o.peerConnection.onremovestream = function (e) { o.onremovestream && o.onremovestream(e) }, o.peerConnection.oniceconnectionstatechange = function (e) { o.oniceconnectionstatechange && o.oniceconnectionstatechange(e.currentTarget.iceConnectionState) }, o.onaddstream = null, o.onremovestream = null, o.state = "new", o.markActionNeeded(), o }, e.Erizo = t, e.L = n
}(window), function () { function e() { (new L.ElementQueries).init() } this.L = this.L || {}, this.L.ElementQueries = function () { function e(e) { e || (e = document.documentElement); var t = getComputedStyle(e, "fontSize"); return parseFloat(t) || 16 } function t(t, n) { var o = n.replace(/[0-9]*/, ""); switch (n = parseFloat(n), o) { case "px": return n; case "em": return n * e(t); case "rem": return n * e(); case "vw": return n * document.documentElement.clientWidth / 100; case "vh": return n * document.documentElement.clientHeight / 100; case "vmin": case "vmax": var r = document.documentElement.clientWidth / 100, i = document.documentElement.clientHeight / 100, s = Math["vmin" === o ? "min" : "max"]; return n * s(r, i); default: return n } } function n(e) { this.element = e, this.options = []; var n, o, r, i, s, a, c, d, u = 0, l = 0; this.addOption = function (e) { this.options.push(e) }; var p = ["min-width", "min-height", "max-width", "max-height"]; this.call = function () { for (u = this.element.offsetWidth, l = this.element.offsetHeight, a = {}, n = 0, o = this.options.length; o > n; n++) r = this.options[n], i = t(this.element, r.value), s = "width" == r.property ? u : l, d = r.mode + "-" + r.property, c = "", "min" == r.mode && s >= i && (c += r.value), "max" == r.mode && i >= s && (c += r.value), a[d] || (a[d] = ""), c && -1 === (" " + a[d] + " ").indexOf(" " + c + " ") && (a[d] += " " + c); for (var e in p) a[p[e]] ? this.element.setAttribute(p[e], a[p[e]].substr(1)) : this.element.removeAttribute(p[e]) } } function o(e, t) { e.elementQueriesSetupInformation ? e.elementQueriesSetupInformation.addOption(t) : (e.elementQueriesSetupInformation = new n(e), e.elementQueriesSetupInformation.addOption(t), new ResizeSensor(e, function () { e.elementQueriesSetupInformation.call() })), e.elementQueriesSetupInformation.call() } function r(e, t, n, r) { var i; if (document.querySelectorAll && (i = document.querySelectorAll.bind(document)), i || "undefined" == typeof $$ || (i = $$), i || "undefined" == typeof jQuery || (i = jQuery), !i) throw "No document.querySelectorAll, jQuery or Mootools's $$ found."; for (var s = i(e), a = 0, c = s.length; c > a; a++) o(s[a], { mode: t, property: n, value: r }) } function i(e) { var t; for (e = e.replace(/'/g, '"') ; null !== (t = a.exec(e)) ;) 5 < t.length && r(t[1] || t[5], t[2], t[3], t[4]) } function s(e) { var t = ""; if (e) if ("string" == typeof e) e = e.toLowerCase(), (-1 !== e.indexOf("min-width") || -1 !== e.indexOf("max-width")) && i(e); else for (var n = 0, o = e.length; o > n; n++) 1 === e[n].type ? (t = e[n].selectorText || e[n].cssText, -1 !== t.indexOf("min-height") || -1 !== t.indexOf("max-height") ? i(t) : (-1 !== t.indexOf("min-width") || -1 !== t.indexOf("max-width")) && i(t)) : 4 === e[n].type && s(e[n].cssRules || e[n].rules) } var a = /,?([^,\n]*)\[[\s\t]*(min|max)-(width|height)[\s\t]*[~$\^]?=[\s\t]*"([^"]*)"[\s\t]*]([^\n\s\{]*)/gim; this.init = function () { for (var e = 0, t = document.styleSheets.length; t > e; e++) s(document.styleSheets[e].cssText || document.styleSheets[e].cssRules || document.styleSheets[e].rules) } }, window.addEventListener ? window.addEventListener("load", e, !1) : window.attachEvent("onload", e), this.L.ResizeSensor = function (e, t) { function n(e, t) { window.OverflowEvent ? e.addEventListener("overflowchanged", function (e) { t.call(this, e) }) : (e.addEventListener("overflow", function (e) { t.call(this, e) }), e.addEventListener("underflow", function (e) { t.call(this, e) })) } function o() { this.q = [], this.add = function (e) { this.q.push(e) }; var e, t; this.call = function () { for (e = 0, t = this.q.length; t > e; e++) this.q[e].call() } } function r(e, t) { return e.currentStyle ? e.currentStyle[t] : window.getComputedStyle ? window.getComputedStyle(e, null).getPropertyValue(t) : e.style[t] } function i(e, t) { function i() { var t = !1, n = e.resizeSensor.offsetWidth, o = e.resizeSensor.offsetHeight; return c != n && (u.width = n - 1 + "px", l.width = n + 1 + "px", t = !0, c = n), d != o && (u.height = o - 1 + "px", l.height = o + 1 + "px", t = !0, d = o), t } if (e.resizedAttached) { if (e.resizedAttached) return void e.resizedAttached.add(t) } else e.resizedAttached = new o, e.resizedAttached.add(t); var s = function () { i() && e.resizedAttached.call() }; e.resizeSensor = document.createElement("div"), e.resizeSensor.className = "resize-sensor"; var a = "position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1;"; e.resizeSensor.style.cssText = a, e.resizeSensor.innerHTML = '<div class="resize-sensor-overflow" style="' + a + '"><div></div></div><div class="resize-sensor-underflow" style="' + a + '"><div></div></div>', e.appendChild(e.resizeSensor), "absolute" !== r(e, "position") && (e.style.position = "relative"); var c = -1, d = -1, u = e.resizeSensor.firstElementChild.firstChild.style, l = e.resizeSensor.lastElementChild.firstChild.style; i(), n(e.resizeSensor, s), n(e.resizeSensor.firstElementChild, s), n(e.resizeSensor.lastElementChild, s) } if ("array" == typeof e || "undefined" != typeof jQuery && e instanceof jQuery || "undefined" != typeof Elements && e instanceof Elements) for (var s = 0, a = e.length; a > s; s++) i(e[s], t); else i(e, t) } }(), function (e, t) { var n = e; n.version = "0.9.6", n.protocol = 1, n.transports = [], n.j = [], n.sockets = {}, n.connect = function (e, o) { var r, i, s = n.util.parseUri(e); t && t.location && (s.protocol = s.protocol || t.location.protocol.slice(0, -1), s.host = s.host || (t.document ? t.document.domain : t.location.hostname), s.port = s.port || t.location.port), r = n.util.uniqueUri(s); var a = { host: s.host, secure: "https" == s.protocol, port: s.port || ("https" == s.protocol ? 443 : 80), query: s.query || "" }; return n.util.merge(a, o), (a["force new connection"] || !n.sockets[r]) && (i = new n.Socket(a)), !a["force new connection"] && i && (n.sockets[r] = i), i = i || n.sockets[r], i.of(s.path.length > 1 ? s.path : "") } }("object" == typeof module ? module.exports : this.io = {}, this), function (e, t) {
var n = e.util = {}, o = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, r = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]; n.parseUri = function (e) { for (var t = o.exec(e || ""), n = {}, i = 14; i--;) n[r[i]] = t[i] || ""; return n }, n.uniqueUri = function (e) { var n = e.protocol, o = e.host, r = e.port; return "document" in t ? (o = o || document.domain, r = r || ("https" == n && "https:" !== document.location.protocol ? 443 : document.location.port)) : (o = o || "localhost", r || "https" != n || (r = 443)), (n || "http") + "://" + o + ":" + (r || 80) }, n.query = function (e, t) { var o = n.chunkQuery(e || ""), r = []; n.merge(o, n.chunkQuery(t || "")); for (var i in o) o.hasOwnProperty(i) && r.push(i + "=" + o[i]); return r.length ? "?" + r.join("&") : "" }, n.chunkQuery = function (e) { for (var t, n = {}, o = e.split("&"), r = 0, i = o.length; i > r; ++r) t = o[r].split("="), t[0] && (n[t[0]] = t[1]); return n }; var i = !1; n.load = function (e) { return "document" in t && "complete" === document.readyState || i ? e() : void n.on(t, "load", e, !1) }, n.on = function (e, t, n, o) { e.attachEvent ? e.attachEvent("on" + t, n) : e.addEventListener && e.addEventListener(t, n, o) }, n.request = function (e) { if (e && "undefined" != typeof XDomainRequest) return new XDomainRequest; if ("undefined" != typeof XMLHttpRequest && (!e || n.ua.hasCORS)) return new XMLHttpRequest; if (!e) try { return new (window[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP") } catch (t) { } return null }, "undefined" != typeof window && n.load(function () { i = !0 }), n.defer = function (e) {
return n.ua.webkit && "undefined" == typeof importScripts ? void n.load(function () {
setTimeout(e, 100);
}) : e()
}, n.merge = function (e, t, o, r) { var i, s = r || [], a = "undefined" == typeof o ? 2 : o; for (i in t) t.hasOwnProperty(i) && n.indexOf(s, i) < 0 && ("object" == typeof e[i] && a ? n.merge(e[i], t[i], a - 1, s) : (e[i] = t[i], s.push(t[i]))); return e }, n.mixin = function (e, t) { n.merge(e.prototype, t.prototype) }, n.inherit = function (e, t) { function n() { } n.prototype = t.prototype, e.prototype = new n }, n.isArray = Array.isArray || function (e) { return "[object Array]" === Object.prototype.toString.call(e) }, n.intersect = function (e, t) { for (var o = [], r = e.length > t.length ? e : t, i = e.length > t.length ? t : e, s = 0, a = i.length; a > s; s++) ~n.indexOf(r, i[s]) && o.push(i[s]); return o }, n.indexOf = function (e, t, n) { for (var o = e.length, n = 0 > n ? 0 > n + o ? 0 : n + o : n || 0; o > n && e[n] !== t; n++); return n >= o ? -1 : n }, n.toArray = function (e) { for (var t = [], n = 0, o = e.length; o > n; n++) t.push(e[n]); return t }, n.ua = {}, n.ua.hasCORS = "undefined" != typeof XMLHttpRequest && function () { try { var e = new XMLHttpRequest } catch (t) { return !1 } return void 0 != e.withCredentials }(), n.ua.webkit = "undefined" != typeof navigator && /webkit/i.test(navigator.userAgent)
}("undefined" != typeof io ? io : module.exports, this), function (e, t) { function n() { } e.EventEmitter = n, n.prototype.on = function (e, n) { return this.$events || (this.$events = {}), this.$events[e] ? t.util.isArray(this.$events[e]) ? this.$events[e].push(n) : this.$events[e] = [this.$events[e], n] : this.$events[e] = n, this }, n.prototype.addListener = n.prototype.on, n.prototype.once = function (e, t) { function n() { o.removeListener(e, n), t.apply(this, arguments) } var o = this; return n.listener = t, this.on(e, n), this }, n.prototype.removeListener = function (e, n) { if (this.$events && this.$events[e]) { var o = this.$events[e]; if (t.util.isArray(o)) { for (var r = -1, i = 0, s = o.length; s > i; i++) if (o[i] === n || o[i].listener && o[i].listener === n) { r = i; break } if (0 > r) return this; o.splice(r, 1), o.length || delete this.$events[e] } else (o === n || o.listener && o.listener === n) && delete this.$events[e] } return this }, n.prototype.removeAllListeners = function (e) { return this.$events && this.$events[e] && (this.$events[e] = null), this }, n.prototype.listeners = function (e) { return this.$events || (this.$events = {}), this.$events[e] || (this.$events[e] = []), t.util.isArray(this.$events[e]) || (this.$events[e] = [this.$events[e]]), this.$events[e] }, n.prototype.emit = function (e) { if (!this.$events) return !1; var n = this.$events[e]; if (!n) return !1; var o = Array.prototype.slice.call(arguments, 1); if ("function" == typeof n) n.apply(this, o); else { if (!t.util.isArray(n)) return !1; for (var r = n.slice(), i = 0, s = r.length; s > i; i++) r[i].apply(this, o) } return !0 } }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function (exports, nativeJSON) { "use strict"; function f(e) { return 10 > e ? "0" + e : e } function date(e, t) { return isFinite(e.valueOf()) ? e.getUTCFullYear() + "-" + f(e.getUTCMonth() + 1) + "-" + f(e.getUTCDate()) + "T" + f(e.getUTCHours()) + ":" + f(e.getUTCMinutes()) + ":" + f(e.getUTCSeconds()) + "Z" : null } function quote(e) { return escapable.lastIndex = 0, escapable.test(e) ? '"' + e.replace(escapable, function (e) { var t = meta[e]; return "string" == typeof t ? t : "\\u" + ("0000" + e.charCodeAt(0).toString(16)).slice(-4) }) + '"' : '"' + e + '"' } function str(e, t) { var n, o, r, i, s, a = gap, c = t[e]; switch (c instanceof Date && (c = date(e)), "function" == typeof rep && (c = rep.call(t, e, c)), typeof c) { case "string": return quote(c); case "number": return isFinite(c) ? String(c) : "null"; case "boolean": case "null": return String(c); case "object": if (!c) return "null"; if (gap += indent, s = [], "[object Array]" === Object.prototype.toString.apply(c)) { for (i = c.length, n = 0; i > n; n += 1) s[n] = str(n, c) || "null"; return r = 0 === s.length ? "[]" : gap ? "[\n" + gap + s.join(",\n" + gap) + "\n" + a + "]" : "[" + s.join(",") + "]", gap = a, r } if (rep && "object" == typeof rep) for (i = rep.length, n = 0; i > n; n += 1) "string" == typeof rep[n] && (o = rep[n], r = str(o, c), r && s.push(quote(o) + (gap ? ": " : ":") + r)); else for (o in c) Object.prototype.hasOwnProperty.call(c, o) && (r = str(o, c), r && s.push(quote(o) + (gap ? ": " : ":") + r)); return r = 0 === s.length ? "{}" : gap ? "{\n" + gap + s.join(",\n" + gap) + "\n" + a + "}" : "{" + s.join(",") + "}", gap = a, r } } if (nativeJSON && nativeJSON.parse) return exports.JSON = { parse: nativeJSON.parse, stringify: nativeJSON.stringify }; var JSON = exports.JSON = {}, cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }, rep; JSON.stringify = function (e, t, n) { var o; if (gap = "", indent = "", "number" == typeof n) for (o = 0; n > o; o += 1) indent += " "; else "string" == typeof n && (indent = n); if (rep = t, t && "function" != typeof t && ("object" != typeof t || "number" != typeof t.length)) throw new Error("JSON.stringify"); return str("", { "": e }) }, JSON.parse = function (text, reviver) { function walk(e, t) { var n, o, r = e[t]; if (r && "object" == typeof r) for (n in r) Object.prototype.hasOwnProperty.call(r, n) && (o = walk(r, n), void 0 !== o ? r[n] = o : delete r[n]); return reviver.call(e, t, r) } var j; if (text = String(text), cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function (e) { return "\\u" + ("0000" + e.charCodeAt(0).toString(16)).slice(-4) })), /^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return j = eval("(" + text + ")"), "function" == typeof reviver ? walk({ "": j }, "") : j; throw new SyntaxError("JSON.parse") } }("undefined" != typeof io ? io : module.exports, "undefined" != typeof JSON ? JSON : void 0), function (e, t) { var n = e.parser = {}, o = n.packets = ["disconnect", "connect", "heartbeat", "message", "json", "event", "ack", "error", "noop"], r = n.reasons = ["transport not supported", "client not handshaken", "unauthorized"], i = n.advice = ["reconnect"], s = t.JSON, a = t.util.indexOf; n.encodePacket = function (e) { var t = a(o, e.type), n = e.id || "", c = e.endpoint || "", d = e.ack, u = null; switch (e.type) { case "error": var l = e.reason ? a(r, e.reason) : "", p = e.advice ? a(i, e.advice) : ""; ("" !== l || "" !== p) && (u = l + ("" !== p ? "+" + p : "")); break; case "message": "" !== e.data && (u = e.data); break; case "event": var f = { name: e.name }; e.args && e.args.length && (f.args = e.args), u = s.stringify(f); break; case "json": u = s.stringify(e.data); break; case "connect": e.qs && (u = e.qs); break; case "ack": u = e.ackId + (e.args && e.args.length ? "+" + s.stringify(e.args) : "") } var m = [t, n + ("data" == d ? "+" : ""), c]; return null !== u && void 0 !== u && m.push(u), m.join(":") }, n.encodePayload = function (e) { var t = ""; if (1 == e.length) return e[0]; for (var n = 0, o = e.length; o > n; n++) { var r = e[n]; t += "�" + r.length + "�" + e[n] } return t }; var c = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/; n.decodePacket = function (e) { var t = e.match(c); if (!t) return {}; var n = t[2] || "", e = t[5] || "", a = { type: o[t[1]], endpoint: t[4] || "" }; switch (n && (a.id = n, t[3] ? a.ack = "data" : a.ack = !0), a.type) { case "error": var t = e.split("+"); a.reason = r[t[0]] || "", a.advice = i[t[1]] || ""; break; case "message": a.data = e || ""; break; case "event": try { var d = s.parse(e); a.name = d.name, a.args = d.args } catch (u) { } a.args = a.args || []; break; case "json": try { a.data = s.parse(e) } catch (u) { } break; case "connect": a.qs = e || ""; break; case "ack": var t = e.match(/^([0-9]+)(\+)?(.*)/); if (t && (a.ackId = t[1], a.args = [], t[3])) try { a.args = t[3] ? s.parse(t[3]) : [] } catch (u) { } break; case "disconnect": case "heartbeat": } return a }, n.decodePayload = function (e) { if ("�" == e.charAt(0)) { for (var t = [], o = 1, r = ""; o < e.length; o++) "�" == e.charAt(o) ? (t.push(n.decodePacket(e.substr(o + 1).substr(0, r))), o += Number(r) + 1, r = "") : r += e.charAt(o); return t } return [n.decodePacket(e)] } }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function (e, t) { function n(e, t) { this.socket = e, this.sessid = t } e.Transport = n, t.util.mixin(n, t.EventEmitter), n.prototype.onData = function (e) { if (this.clearCloseTimeout(), (this.socket.connected || this.socket.connecting || this.socket.reconnecting) && this.setCloseTimeout(), "" !== e) { var n = t.parser.decodePayload(e); if (n && n.length) for (var o = 0, r = n.length; r > o; o++) this.onPacket(n[o]) } return this }, n.prototype.onPacket = function (e) { return this.socket.setHeartbeatTimeout(), "heartbeat" == e.type ? this.onHeartbeat() : ("connect" == e.type && "" == e.endpoint && this.onConnect(), "error" == e.type && "reconnect" == e.advice && (this.open = !1), this.socket.onPacket(e), this) }, n.prototype.setCloseTimeout = function () { if (!this.closeTimeout) { var e = this; this.closeTimeout = setTimeout(function () { e.onDisconnect() }, this.socket.closeTimeout) } }, n.prototype.onDisconnect = function () { return this.close && this.open && this.close(), this.clearTimeouts(), this.socket.onDisconnect(), this }, n.prototype.onConnect = function () { return this.socket.onConnect(), this }, n.prototype.clearCloseTimeout = function () { this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null) }, n.prototype.clearTimeouts = function () { this.clearCloseTimeout(), this.reopenTimeout && clearTimeout(this.reopenTimeout) }, n.prototype.packet = function (e) { this.send(t.parser.encodePacket(e)) }, n.prototype.onHeartbeat = function (e) { this.packet({ type: "heartbeat" }) }, n.prototype.onOpen = function () { this.open = !0, this.clearCloseTimeout(), this.socket.onOpen() }, n.prototype.onClose = function () { var e = this; this.reopenTimeout = setTimeout(function () { e.open() }, this.socket.options["reopen delay"]), this.open = !1, this.socket.onClose(), this.onDisconnect() }, n.prototype.prepareUrl = function () { var e = this.socket.options; return this.scheme() + "://" + e.host + ":" + e.port + "/" + e.resource + "/" + t.protocol + "/" + this.name + "/" + this.sessid }, n.prototype.ready = function (e, t) { t.call(this) } }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function (e, t, n) { function o(e) { if (this.options = { port: 80, secure: !1, document: "document" in n ? document : !1, resource: "socket.io", transports: t.transports, "connect timeout": 1e4, "try multiple transports": !0, reconnect: !0, "reconnection delay": 500, "reconnection limit": 1 / 0, "reopen delay": 3e3, "max reconnection attempts": 10, "sync disconnect on unload": !0, "auto connect": !0, "flash policy port": 10843 }, t.util.merge(this.options, e), this.connected = !1, this.open = !1, this.connecting = !1, this.reconnecting = !1, this.namespaces = {}, this.buffer = [], this.doBuffer = !1, this.options["sync disconnect on unload"] && (!this.isXDomain() || t.util.ua.hasCORS)) { var o = this; t.util.on(n, "unload", function () { o.disconnectSync() }, !1) } this.options["auto connect"] && this.connect() } function r() { } e.Socket = o, t.util.mixin(o, t.EventEmitter), o.prototype.of = function (e) { return this.namespaces[e] || (this.namespaces[e] = new t.SocketNamespace(this, e), "" !== e && this.namespaces[e].packet({ type: "connect" })), this.namespaces[e] }, o.prototype.publish = function () { this.emit.apply(this, arguments); var e; for (var t in this.namespaces) this.namespaces.hasOwnProperty(t) && (e = this.of(t), e.$emit.apply(e, arguments)) }, o.prototype.handshake = function (e) { function n(t) { t instanceof Error ? o.onError(t.message) : e.apply(null, t.split(":")) } var o = this, i = this.options, s = ["http" + (i.secure ? "s" : "") + ":/", i.host + ":" + i.port, i.resource, t.protocol, t.util.query(this.options.query, "t=" + +new Date)].join("/"); if (this.isXDomain() && !t.util.ua.hasCORS) { var a = document.getElementsByTagName("script")[0], c = document.createElement("script"); c.src = s + "&jsonp=" + t.j.length, a.parentNode.insertBefore(c, a), t.j.push(function (e) { n(e), c.parentNode.removeChild(c) }) } else { var d = t.util.request(); d.open("GET", s, !0), d.withCredentials = !0, d.onreadystatechange = function () { 4 == d.readyState && (d.onreadystatechange = r, 200 == d.status ? n(d.responseText) : !o.reconnecting && o.onError(d.responseText)) }, d.send(null) } }, o.prototype.getTransport = function (e) { for (var n, o = e || this.transports, r = 0; n = o[r]; r++) if (t.Transport[n] && t.Transport[n].check(this) && (!this.isXDomain() || t.Transport[n].xdomainCheck())) return new t.Transport[n](this, this.sessionid); return null }, o.prototype.connect = function (e) { if (this.connecting) return this; var n = this; return this.handshake(function (o, r, i, s) { function a(e) { return n.transport && n.transport.clearTimeouts(), n.transport = n.getTransport(e), n.transport ? void n.transport.ready(n, function () { n.connecting = !0, n.publish("connecting", n.transport.name), n.transport.open(), n.options["connect timeout"] && (n.connectTimeoutTimer = setTimeout(function () { if (!n.connected && (n.connecting = !1, n.options["try multiple transports"])) { n.remainingTransports || (n.remainingTransports = n.transports.slice(0)); for (var e = n.remainingTransports; e.length > 0 && e.splice(0, 1)[0] != n.transport.name;); e.length ? a(e) : n.publish("connect_failed") } }, n.options["connect timeout"])) }) : n.publish("connect_failed") } n.sessionid = o, n.closeTimeout = 1e3 * i, n.heartbeatTimeout = 1e3 * r, n.transports = s ? t.util.intersect(s.split(","), n.options.transports) : n.options.transports, n.setHeartbeatTimeout(), a(n.transports), n.once("connect", function () { clearTimeout(n.connectTimeoutTimer), e && "function" == typeof e && e() }) }), this }, o.prototype.setHeartbeatTimeout = function () { clearTimeout(this.heartbeatTimeoutTimer); var e = this; this.heartbeatTimeoutTimer = setTimeout(function () { e.transport.onClose() }, this.heartbeatTimeout) }, o.prototype.packet = function (e) { return this.connected && !this.doBuffer ? this.transport.packet(e) : this.buffer.push(e), this }, o.prototype.setBuffer = function (e) { this.doBuffer = e, !e && this.connected && this.buffer.length && (this.transport.payload(this.buffer), this.buffer = []) }, o.prototype.disconnect = function () { return (this.connected || this.connecting) && (this.open && this.of("").packet({ type: "disconnect" }), this.onDisconnect("booted")), this }, o.prototype.disconnectSync = function () { var e = t.util.request(), n = this.resource + "/" + t.protocol + "/" + this.sessionid; e.open("GET", n, !0), this.onDisconnect("booted") }, o.prototype.isXDomain = function () { var e = n.location.port || ("https:" == n.location.protocol ? 443 : 80); return this.options.host !== n.location.hostname || this.options.port != e }, o.prototype.onConnect = function () { this.connected || (this.connected = !0, this.connecting = !1, this.doBuffer || this.setBuffer(!1), this.emit("connect")) }, o.prototype.onOpen = function () { this.open = !0 }, o.prototype.onClose = function () { this.open = !1, clearTimeout(this.heartbeatTimeoutTimer) }, o.prototype.onPacket = function (e) { this.of(e.endpoint).onPacket(e) }, o.prototype.onError = function (e) { e && e.advice && "reconnect" === e.advice && (this.connected || this.connecting) && (this.disconnect(), this.options.reconnect && this.reconnect()), this.publish("error", e && e.reason ? e.reason : e) }, o.prototype.onDisconnect = function (e) { var t = this.connected, n = this.connecting; this.connected = !1, this.connecting = !1, this.open = !1, (t || n) && (this.transport.close(), this.transport.clearTimeouts(), t && (this.publish("disconnect", e), "booted" != e && this.options.reconnect && !this.reconnecting && this.reconnect())) }, o.prototype.reconnect = function () { function e() { if (n.connected) { for (var e in n.namespaces) n.namespaces.hasOwnProperty(e) && "" !== e && n.namespaces[e].packet({ type: "connect" }); n.publish("reconnect", n.transport.name, n.reconnectionAttempts) } clearTimeout(n.reconnectionTimer), n.removeListener("connect_failed", t), n.removeListener("connect", t), n.reconnecting = !1, delete n.reconnectionAttempts, delete n.reconnectionDelay, delete n.reconnectionTimer, delete n.redoTransports, n.options["try multiple transports"] = r } function t() { return n.reconnecting ? n.connected ? e() : n.connecting && n.reconnecting ? n.reconnectionTimer = setTimeout(t, 1e3) : void (n.reconnectionAttempts++ >= o ? n.redoTransports ? (n.publish("reconnect_failed"), e()) : (n.on("connect_failed", t), n.options["try multiple transports"] = !0, n.transport = n.getTransport(), n.redoTransports = !0, n.connect()) : (n.reconnectionDelay < i && (n.reconnectionDelay *= 2), n.connect(), n.publish("reconnecting", n.reconnectionDelay, n.reconnectionAttempts), n.reconnectionTimer = setTimeout(t, n.reconnectionDelay))) : void 0 } this.reconnecting = !0, this.reconnectionAttempts = 0, this.reconnectionDelay = this.options["reconnection delay"]; var n = this, o = this.options["max reconnection attempts"], r = this.options["try multiple transports"], i = this.options["reconnection limit"]; this.options["try multiple transports"] = !1, this.reconnectionTimer = setTimeout(t, this.reconnectionDelay), this.on("connect", t) } }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), function (e, t) { function n(e, t) { this.socket = e, this.name = t || "", this.flags = {}, this.json = new o(this, "json"), this.ackPackets = 0, this.acks = {} } function o(e, t) { this.namespace = e, this.name = t } e.SocketNamespace = n, t.util.mixin(n, t.EventEmitter), n.prototype.$emit = t.EventEmitter.prototype.emit, n.prototype.of = function () { return this.socket.of.apply(this.socket, arguments) }, n.prototype.packet = function (e) { return e.endpoint = this.name, this.socket.packet(e), this.flags = {}, this }, n.prototype.send = function (e, t) { var n = { type: this.flags.json ? "json" : "message", data: e }; return "function" == typeof t && (n.id = ++this.ackPackets, n.ack = !0, this.acks[n.id] = t), this.packet(n) }, n.prototype.emit = function (e) { var t = Array.prototype.slice.call(arguments, 1), n = t[t.length - 1], o = { type: "event", name: e }; return "function" == typeof n && (o.id = ++this.ackPackets, o.ack = "data", this.acks[o.id] = n, t = t.slice(0, t.length - 1)), o.args = t, this.packet(o) }, n.prototype.disconnect = function () { return "" === this.name ? this.socket.disconnect() : (this.packet({ type: "disconnect" }), this.$emit("disconnect")), this }, n.prototype.onPacket = function (e) { function n() { o.packet({ type: "ack", args: t.util.toArray(arguments), ackId: e.id }) } var o = this; switch (e.type) { case "connect": this.$emit("connect"); break; case "disconnect": "" === this.name ? this.socket.onDisconnect(e.reason || "booted") : this.$emit("disconnect", e.reason); break; case "message": case "json": var r = ["message", e.data]; "data" == e.ack ? r.push(n) : e.ack && this.packet({ type: "ack", ackId: e.id }), this.$emit.apply(this, r); break; case "event": var r = [e.name].concat(e.args); "data" == e.ack && r.push(n), this.$emit.apply(this, r); break; case "ack": this.acks[e.ackId] && (this.acks[e.ackId].apply(this, e.args), delete this.acks[e.ackId]); break; case "error": e.advice ? this.socket.onError(e) : "unauthorized" == e.reason ? this.$emit("connect_failed", e.reason) : this.$emit("error", e.reason) } }, o.prototype.send = function () { this.namespace.flags[this.name] = !0, this.namespace.send.apply(this.namespace, arguments) }, o.prototype.emit = function () { this.namespace.flags[this.name] = !0, this.namespace.emit.apply(this.namespace, arguments) } }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), function (e, t, n) { function o(e) { t.Transport.apply(this, arguments) } e.websocket = o, t.util.inherit(o, t.Transport), o.prototype.name = "websocket", o.prototype.open = function () { var e, o = t.util.query(this.socket.options.query), r = this; return e || (e = n.MozWebSocket || n.WebSocket), this.websocket = new e(this.prepareUrl() + o), this.websocket.onopen = function () { r.onOpen(), r.socket.setBuffer(!1) }, this.websocket.onmessage = function (e) { r.onData(e.data) }, this.websocket.onclose = function () { r.onClose(), r.socket.setBuffer(!0) }, this.websocket.onerror = function (e) { r.onError(e) }, this }, o.prototype.send = function (e) { return this.websocket.send(e), this }, o.prototype.payload = function (e) { for (var t = 0, n = e.length; n > t; t++) this.packet(e[t]); return this }, o.prototype.close = function () { return this.websocket.close(), this }, o.prototype.onError = function (e) { this.socket.onError(e) }, o.prototype.scheme = function () { return this.socket.options.secure ? "wss" : "ws" }, o.check = function () { return "WebSocket" in n && !("__addTask" in WebSocket) || "MozWebSocket" in n }, o.xdomainCheck = function () { return !0 }, t.transports.push("websocket") }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), function (e, t) { function n() { t.Transport.websocket.apply(this, arguments) } e.flashsocket = n, t.util.inherit(n, t.Transport.websocket), n.prototype.name = "flashsocket", n.prototype.open = function () { var e = this, n = arguments; return WebSocket.__addTask(function () { t.Transport.websocket.prototype.open.apply(e, n) }), this }, n.prototype.send = function () { var e = this, n = arguments; return WebSocket.__addTask(function () { t.Transport.websocket.prototype.send.apply(e, n) }), this }, n.prototype.close = function () { return WebSocket.__tasks.length = 0, t.Transport.websocket.prototype.close.call(this), this }, n.prototype.ready = function (e, o) { function r() { var t = e.options, r = t["flash policy port"], s = ["http" + (t.secure ? "s" : "") + ":/", t.host + ":" + t.port, t.resource, "static/flashsocket", "WebSocketMain" + (e.isXDomain() ? "Insecure" : "") + ".swf"]; n.loaded || ("undefined" == typeof WEB_SOCKET_SWF_LOCATION && (WEB_SOCKET_SWF_LOCATION = s.join("/")), 843 !== r && WebSocket.loadFlashPolicyFile("xmlsocket://" + t.host + ":" + r), WebSocket.__initialize(), n.loaded = !0), o.call(i) } var i = this; return document.body ? r() : void t.util.load(r) }, n.check = function () { return "undefined" != typeof WebSocket && "__initialize" in WebSocket && swfobject ? swfobject.getFlashPlayerVersion().major >= 10 : !1 }, n.xdomainCheck = function () { return !0 }, "undefined" != typeof window && (WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = !0), t.transports.push("flashsocket") }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports), "undefined" != typeof window) var swfobject = function () { function e() { if (!q) { try { var e = D.getElementsByTagName("body")[0].appendChild(g("span")); e.parentNode.removeChild(e) } catch (t) { return } q = !0; for (var n = F.length, o = 0; n > o; o++) F[o]() } } function t(e) { q ? e() : F[F.length] = e } function n(e) { if (typeof M.addEventListener != I) M.addEventListener("load", e, !1); else if (typeof D.addEventListener != I) D.addEventListener("load", e, !1); else if (typeof M.attachEvent != I) v(M, "onload", e); else if ("function" == typeof M.onload) { var t = M.onload; M.onload = function () { t(), e() } } else M.onload = e } function o() { W ? r() : i() } function r() { var e = D.getElementsByTagName("body")[0], t = g(O); t.setAttribute("type", x); var n = e.appendChild(t); if (n) { var o = 0; !function () { if (typeof n.GetVariable != I) { var r = n.GetVariable("$version"); r && (r = r.split(" ")[1].split(","), $.pv = [parseInt(r[0], 10), parseInt(r[1], 10), parseInt(r[2], 10)]) } else if (10 > o) return o++, void setTimeout(arguments.callee, 10); e.removeChild(t), n = null, i() }() } else i() } function i() { var e = U.length; if (e > 0) for (var t = 0; e > t; t++) { var n = U[t].id, o = U[t].callbackFn, r = { success: !1, id: n }; if ($.pv[0] > 0) { var i = h(n); if (i) if (!y(U[t].swfVersion) || $.wk && $.wk < 312) if (U[t].expressInstall && a()) { var u = {}; u.data = U[t].expressInstall, u.width = i.getAttribute("width") || "0", u.height = i.getAttribute("height") || "0", i.getAttribute("class") && (u.styleclass = i.getAttribute("class")), i.getAttribute("align") && (u.align = i.getAttribute("align")); for (var l = {}, p = i.getElementsByTagName("param"), f = p.length, m = 0; f > m; m++) "movie" != p[m].getAttribute("name").toLowerCase() && (l[p[m].getAttribute("name")] = p[m].getAttribute("value")); c(u, l, n, o) } else d(i), o && o(r); else b(n, !0), o && (r.success = !0, r.ref = s(n), o(r)) } else if (b(n, !0), o) { var g = s(n); g && typeof g.SetVariable != I && (r.success = !0, r.ref = g), o(r) } } } function s(e) { var t = null, n = h(e); if (n && "OBJECT" == n.nodeName) if (typeof n.SetVariable != I) t = n; else { var o = n.getElementsByTagName(O)[0]; o && (t = o) } return t } function a() { return !z && y("6.0.65") && ($.win || $.mac) && !($.wk && $.wk < 312) } function c(e, t, n, o) { z = !0, _ = o || null, w = { success: !1, id: n }; var r = h(n); if (r) { "OBJECT" == r.nodeName ? (k = u(r), E = null) : (k = r, E = n), e.id = V, (typeof e.width == I || !/%$/.test(e.width) && parseInt(e.width, 10) < 310) && (e.width = "310"), (typeof e.height == I || !/%$/.test(e.height) && parseInt(e.height, 10) < 137) && (e.height = "137"), D.title = D.title.slice(0, 47) + " - Flash Player Installation"; var i = $.ie && $.win ? ["Active"].concat("").join("X") : "PlugIn", s = "MMredirectURL=" + M.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + i + "&MMdoctitle=" + D.title; if (typeof t.flashvars != I ? t.flashvars += "&" + s : t.flashvars = s, $.ie && $.win && 4 != r.readyState) { var a = g("div"); n += "SWFObjectNew", a.setAttribute("id", n), r.parentNode.insertBefore(a, r), r.style.display = "none", function () { 4 == r.readyState ? r.parentNode.removeChild(r) : setTimeout(arguments.callee, 10) }() } l(e, t, n) } } function d(e) { if ($.ie && $.win && 4 != e.readyState) { var t = g("div"); e.parentNode.insertBefore(t, e), t.parentNode.replaceChild(u(e), t), e.style.display = "none", function () { 4 == e.readyState ? e.parentNode.removeChild(e) : setTimeout(arguments.callee, 10) }() } else e.parentNode.replaceChild(u(e), e) } function u(e) { var t = g("div"); if ($.win && $.ie) t.innerHTML = e.innerHTML; else { var n = e.getElementsByTagName(O)[0]; if (n) { var o = n.childNodes; if (o) for (var r = o.length, i = 0; r > i; i++) 1 == o[i].nodeType && "PARAM" == o[i].nodeName || 8 == o[i].nodeType || t.appendChild(o[i].cloneNode(!0)) } } return t } function l(e, t, n) { var o, r = h(n); if ($.wk && $.wk < 312) return o; if (r) if (typeof e.id == I && (e.id = n), $.ie && $.win) { var i = ""; for (var s in e) e[s] != Object.prototype[s] && ("data" == s.toLowerCase() ? t.movie = e[s] : "styleclass" == s.toLowerCase() ? i += ' class="' + e[s] + '"' : "classid" != s.toLowerCase() && (i += " " + s + '="' + e[s] + '"')); var a = ""; for (var c in t) t[c] != Object.prototype[c] && (a += '<param name="' + c + '" value="' + t[c] + '" />'); r.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + i + ">" + a + "</object>", B[B.length] = e.id, o = h(e.id) } else { var d = g(O); d.setAttribute("type", x); for (var u in e) e[u] != Object.prototype[u] && ("styleclass" == u.toLowerCase() ? d.setAttribute("class", e[u]) : "classid" != u.toLowerCase() && d.setAttribute(u, e[u])); for (var l in t) t[l] != Object.prototype[l] && "movie" != l.toLowerCase() && p(d, l, t[l]); r.parentNode.replaceChild(d, r), o = d } return o } function p(e, t, n) { var o = g("param"); o.setAttribute("name", t), o.setAttribute("value", n), e.appendChild(o) } function f(e) { var t = h(e); t && "OBJECT" == t.nodeName && ($.ie && $.win ? (t.style.display = "none", function () { 4 == t.readyState ? m(e) : setTimeout(arguments.callee, 10) }()) : t.parentNode.removeChild(t)) } function m(e) { var t = h(e); if (t) { for (var n in t) "function" == typeof t[n] && (t[n] = null); t.parentNode.removeChild(t) } } function h(e) { var t = null; try { t = D.getElementById(e) } catch (n) { } return t } function g(e) { return D.createElement(e) } function v(e, t, n) { e.attachEvent(t, n), j[j.length] = [e, t, n] } function y(e) { var t = $.pv, n = e.split("."); return n[0] = parseInt(n[0], 10), n[1] = parseInt(n[1], 10) || 0, n[2] = parseInt(n[2], 10) || 0, t[0] > n[0] || t[0] == n[0] && t[1] > n[1] || t[0] == n[0] && t[1] == n[1] && t[2] >= n[2] ? !0 : !1 } function S(e, t, n, o) { if (!$.ie || !$.mac) { var r = D.getElementsByTagName("head")[0]; if (r) { var i = n && "string" == typeof n ? n : "screen"; if (o && (T = null, A = null), !T || A != i) { var s = g("style"); s.setAttribute("type", "text/css"), s.setAttribute("media", i), T = r.appendChild(s), $.ie && $.win && typeof D.styleSheets != I && D.styleSheets.length > 0 && (T = D.styleSheets[D.styleSheets.length - 1]), A = i } $.ie && $.win ? T && typeof T.addRule == O && T.addRule(e, t) : T && typeof D.createTextNode != I && T.appendChild(D.createTextNode(e + " {" + t + "}")) } } } function b(e, t) { if (H) { var n = t ? "visible" : "hidden"; q && h(e) ? h(e).style.visibility = n : S("#" + e, "visibility:" + n) } } function C(e) { var t = /[\\\"<>\.;]/, n = null != t.exec(e); return n && typeof encodeURIComponent != I ? encodeURIComponent(e) : e } var k, E, _, w, T, A, I = "undefined", O = "object", N = "Shockwave Flash", R = "ShockwaveFlash.ShockwaveFlash", x = "application/x-shockwave-flash", V = "SWFObjectExprInst", L = "onreadystatechange", M = window, D = document, P = navigator, W = !1, F = [o], U = [], B = [], j = [], q = !1, z = !1, H = !0, $ = function () { var e = typeof D.getElementById != I && typeof D.getElementsByTagName != I && typeof D.createElement != I, t = P.userAgent.toLowerCase(), n = P.platform.toLowerCase(), o = n ? /win/.test(n) : /win/.test(t), r = n ? /mac/.test(n) : /mac/.test(t), i = /webkit/.test(t) ? parseFloat(t.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : !1, s = !1, a = [0, 0, 0], c = null; if (typeof P.plugins != I && typeof P.plugins[N] == O) c = P.plugins[N].description, !c || typeof P.mimeTypes != I && P.mimeTypes[x] && !P.mimeTypes[x].enabledPlugin || (W = !0, s = !1, c = c.replace(/^.*\s+(\S+\s+\S+$)/, "$1"), a[0] = parseInt(c.replace(/^(.*)\..*$/, "$1"), 10), a[1] = parseInt(c.replace(/^.*\.(.*)\s.*$/, "$1"), 10), a[2] = /[a-zA-Z]/.test(c) ? parseInt(c.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0); else if (typeof M[["Active"].concat("Object").join("X")] != I) try { var d = new (window[["Active"].concat("Object").join("X")])(R); d && (c = d.GetVariable("$version"), c && (s = !0, c = c.split(" ")[1].split(","), a = [parseInt(c[0], 10), parseInt(c[1], 10), parseInt(c[2], 10)])) } catch (u) { } return { w3: e, pv: a, wk: i, ie: s, win: o, mac: r } }(); (function () { $.w3 && ((typeof D.readyState != I && "complete" == D.readyState || typeof D.readyState == I && (D.getElementsByTagName("body")[0] || D.body)) && e(), q || (typeof D.addEventListener != I && D.addEventListener("DOMContentLoaded", e, !1), $.ie && $.win && (D.attachEvent(L, function () { "complete" == D.readyState && (D.detachEvent(L, arguments.callee), e()) }), M == top && !function () { if (!q) { try { D.documentElement.doScroll("left") } catch (t) { return void setTimeout(arguments.callee, 0) } e() } }()), $.wk && !function () { return q ? void 0 : /loaded|complete/.test(D.readyState) ? void e() : void setTimeout(arguments.callee, 0) }(), n(e))) })(), function () { $.ie && $.win && window.attachEvent("onunload", function () { for (var e = j.length, t = 0; e > t; t++) j[t][0].detachEvent(j[t][1], j[t][2]); for (var n = B.length, o = 0; n > o; o++) f(B[o]); for (var r in $) $[r] = null; $ = null; for (var i in swfobject) swfobject[i] = null; swfobject = null }) }(); return { registerObject: function (e, t, n, o) { if ($.w3 && e && t) { var r = {}; r.id = e, r.swfVersion = t, r.expressInstall = n, r.callbackFn = o, U[U.length] = r, b(e, !1) } else o && o({ success: !1, id: e }) }, getObjectById: function (e) { return $.w3 ? s(e) : void 0 }, embedSWF: function (e, n, o, r, i, s, d, u, p, f) { var m = { success: !1, id: n }; $.w3 && !($.wk && $.wk < 312) && e && n && o && r && i ? (b(n, !1), t(function () { o += "", r += ""; var t = {}; if (p && typeof p === O) for (var h in p) t[h] = p[h]; t.data = e, t.width = o, t.height = r; var g = {}; if (u && typeof u === O) for (var v in u) g[v] = u[v]; if (d && typeof d === O) for (var S in d) typeof g.flashvars != I ? g.flashvars += "&" + S + "=" + d[S] : g.flashvars = S + "=" + d[S]; if (y(i)) { var C = l(t, g, n); t.id == n && b(n, !0), m.success = !0, m.ref = C } else { if (s && a()) return t.data = s, void c(t, g, n, f); b(n, !0) } f && f(m) })) : f && f(m) }, switchOffAutoHideShow: function () { H = !1 }, ua: $, getFlashPlayerVersion: function () { return { major: $.pv[0], minor: $.pv[1], release: $.pv[2] } }, hasFlashPlayerVersion: y, createSWF: function (e, t, n) { return $.w3 ? l(e, t, n) : void 0 }, showExpressInstall: function (e, t, n, o) { $.w3 && a() && c(e, t, n, o) }, removeSWF: function (e) { $.w3 && f(e) }, createCSS: function (e, t, n, o) { $.w3 && S(e, t, n, o) }, addDomLoadEvent: t, addLoadEvent: n, getQueryParamValue: function (e) { var t = D.location.search || D.location.hash; if (t) { if (/\?/.test(t) && (t = t.split("?")[1]), null == e) return C(t); for (var n = t.split("&"), o = 0; o < n.length; o++) if (n[o].substring(0, n[o].indexOf("=")) == e) return C(n[o].substring(n[o].indexOf("=") + 1)) } return "" }, expressInstallCallback: function () { if (z) { var e = h(V); e && k && (e.parentNode.replaceChild(k, e), E && (b(E, !0), $.ie && $.win && (k.style.display = "block")), _ && _(w)), z = !1 } } } }(); !function () {
    if ("undefined" != typeof window && !window.WebSocket) {
        var e = window.console; if (e && e.log && e.error || (e = { log: function () { }, error: function () { } }), !swfobject.hasFlashPlayerVersion("10.0.0")) return void e.error("Flash Player >= 10.0.0 is required."); "file:" == location.protocol && e.error("WARNING: web-socket-js doesn't work in file:///... URL unless you set Flash Security Settings properly. Open the page via Web server i.e. http://..."), WebSocket = function (e, t, n, o, r) { var i = this; i.__id = WebSocket.__nextId++, WebSocket.__instances[i.__id] = i, i.readyState = WebSocket.CONNECTING, i.bufferedAmount = 0, i.__events = {}, t ? "string" == typeof t && (t = [t]) : t = [], setTimeout(function () { WebSocket.__addTask(function () { WebSocket.__flash.create(i.__id, e, t, n || null, o || 0, r || null) }) }, 0) }, WebSocket.prototype.send = function (e) { if (this.readyState == WebSocket.CONNECTING) throw "INVALID_STATE_ERR: Web Socket connection has not been established"; var t = WebSocket.__flash.send(this.__id, encodeURIComponent(e)); return 0 > t ? !0 : (this.bufferedAmount += t, !1) }, WebSocket.prototype.close = function () { this.readyState != WebSocket.CLOSED && this.readyState != WebSocket.CLOSING && (this.readyState = WebSocket.CLOSING, WebSocket.__flash.close(this.__id)) }, WebSocket.prototype.addEventListener = function (e, t, n) { e in this.__events || (this.__events[e] = []), this.__events[e].push(t) }, WebSocket.prototype.removeEventListener = function (e, t, n) { if (e in this.__events) for (var o = this.__events[e], r = o.length - 1; r >= 0; --r) if (o[r] === t) { o.splice(r, 1); break } }, WebSocket.prototype.dispatchEvent = function (e) { for (var t = this.__events[e.type] || [], n = 0; n < t.length; ++n) t[n](e); var o = this["on" + e.type]; o && o(e) }, WebSocket.prototype.__handleEvent = function (e) { "readyState" in e && (this.readyState = e.readyState), "protocol" in e && (this.protocol = e.protocol); var t; if ("open" == e.type || "error" == e.type) t = this.__createSimpleEvent(e.type); else if ("close" == e.type) t = this.__createSimpleEvent("close"); else { if ("message" != e.type) throw "unknown event type: " + e.type; var n = decodeURIComponent(e.message); t = this.__createMessageEvent("message", n) } this.dispatchEvent(t) }, WebSocket.prototype.__createSimpleEvent = function (e) {
            if (document.createEvent && window.Event) {
                var t = document.createEvent("Event"); return t.initEvent(e, !1, !1),
                t
            } return { type: e, bubbles: !1, cancelable: !1 }
        }, WebSocket.prototype.__createMessageEvent = function (e, t) { if (document.createEvent && window.MessageEvent && !window.opera) { var n = document.createEvent("MessageEvent"); return n.initMessageEvent("message", !1, !1, t, null, null, window, null), n } return { type: e, data: t, bubbles: !1, cancelable: !1 } }, WebSocket.CONNECTING = 0, WebSocket.OPEN = 1, WebSocket.CLOSING = 2, WebSocket.CLOSED = 3, WebSocket.__flash = null, WebSocket.__instances = {}, WebSocket.__tasks = [], WebSocket.__nextId = 0, WebSocket.loadFlashPolicyFile = function (e) { WebSocket.__addTask(function () { WebSocket.__flash.loadManualPolicyFile(e) }) }, WebSocket.__initialize = function () { if (!WebSocket.__flash) { if (WebSocket.__swfLocation && (window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation), !window.WEB_SOCKET_SWF_LOCATION) return void e.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf"); var t = document.createElement("div"); t.id = "webSocketContainer", t.style.position = "absolute", WebSocket.__isFlashLite() ? (t.style.left = "0px", t.style.top = "0px") : (t.style.left = "-100px", t.style.top = "-100px"); var n = document.createElement("div"); n.id = "webSocketFlash", t.appendChild(n), document.body.appendChild(t), swfobject.embedSWF(WEB_SOCKET_SWF_LOCATION, "webSocketFlash", "1", "1", "10.0.0", null, null, { hasPriority: !0, swliveconnect: !0, allowScriptAccess: "always" }, null, function (t) { t.success || e.error("[WebSocket] swfobject.embedSWF failed") }) } }, WebSocket.__onFlashInitialized = function () { setTimeout(function () { WebSocket.__flash = document.getElementById("webSocketFlash"), WebSocket.__flash.setCallerUrl(location.href), WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG); for (var e = 0; e < WebSocket.__tasks.length; ++e) WebSocket.__tasks[e](); WebSocket.__tasks = [] }, 0) }, WebSocket.__onFlashEvent = function () { return setTimeout(function () { try { for (var t = WebSocket.__flash.receiveEvents(), n = 0; n < t.length; ++n) WebSocket.__instances[t[n].webSocketId].__handleEvent(t[n]) } catch (o) { e.error(o) } }, 0), !0 }, WebSocket.__log = function (t) { e.log(decodeURIComponent(t)) }, WebSocket.__error = function (t) { e.error(decodeURIComponent(t)) }, WebSocket.__addTask = function (e) { WebSocket.__flash ? e() : WebSocket.__tasks.push(e) }, WebSocket.__isFlashLite = function () { if (!window.navigator || !window.navigator.mimeTypes) return !1; var e = window.navigator.mimeTypes["application/x-shockwave-flash"]; return e && e.enabledPlugin && e.enabledPlugin.filename && e.enabledPlugin.filename.match(/flashlite/i) ? !0 : !1 }, window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION || (window.addEventListener ? window.addEventListener("load", function () { WebSocket.__initialize() }, !1) : window.attachEvent("onload", function () { WebSocket.__initialize() }))
    }
}(), function (e, t, n) { function o(e) { e && (t.Transport.apply(this, arguments), this.sendBuffer = []) } function r() { } e.XHR = o, t.util.inherit(o, t.Transport), o.prototype.open = function () { return this.socket.setBuffer(!1), this.onOpen(), this.get(), this.setCloseTimeout(), this }, o.prototype.payload = function (e) { for (var n = [], o = 0, r = e.length; r > o; o++) n.push(t.parser.encodePacket(e[o])); this.send(t.parser.encodePayload(n)) }, o.prototype.send = function (e) { return this.post(e), this }, o.prototype.post = function (e) { function t() { 4 == this.readyState && (this.onreadystatechange = r, i.posting = !1, 200 == this.status ? i.socket.setBuffer(!1) : i.onClose()) } function o() { this.onload = r, i.socket.setBuffer(!1) } var i = this; this.socket.setBuffer(!0), this.sendXHR = this.request("POST"), n.XDomainRequest && this.sendXHR instanceof XDomainRequest ? this.sendXHR.onload = this.sendXHR.onerror = o : this.sendXHR.onreadystatechange = t, this.sendXHR.send(e) }, o.prototype.close = function () { return this.onClose(), this }, o.prototype.request = function (e) { var n = t.util.request(this.socket.isXDomain()), o = t.util.query(this.socket.options.query, "t=" + +new Date); if (n.open(e || "GET", this.prepareUrl() + o, !0), "POST" == e) try { n.setRequestHeader ? n.setRequestHeader("Content-type", "text/plain;charset=UTF-8") : n.contentType = "text/plain" } catch (r) { } return n }, o.prototype.scheme = function () { return this.socket.options.secure ? "https" : "http" }, o.check = function (e, o) { try { var r = t.util.request(o), i = n.XDomainRequest && r instanceof XDomainRequest, s = e && e.options && e.options.secure ? "https:" : "http:", a = s != n.location.protocol; if (r && (!i || !a)) return !0 } catch (c) { } return !1 }, o.xdomainCheck = function () { return o.check(null, !0) } }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), function (e, t) { function n(e) { t.Transport.XHR.apply(this, arguments) } e.htmlfile = n, t.util.inherit(n, t.Transport.XHR), n.prototype.name = "htmlfile", n.prototype.get = function () { this.doc = new (window[["Active"].concat("Object").join("X")])("htmlfile"), this.doc.open(), this.doc.write("<html></html>"), this.doc.close(), this.doc.parentWindow.s = this; var e = this.doc.createElement("div"); e.className = "socketio", this.doc.body.appendChild(e), this.iframe = this.doc.createElement("iframe"), e.appendChild(this.iframe); var n = this, o = t.util.query(this.socket.options.query, "t=" + +new Date); this.iframe.src = this.prepareUrl() + o, t.util.on(window, "unload", function () { n.destroy() }) }, n.prototype._ = function (e, t) { this.onData(e); try { var n = t.getElementsByTagName("script")[0]; n.parentNode.removeChild(n) } catch (o) { } }, n.prototype.destroy = function () { if (this.iframe) { try { this.iframe.src = "about:blank" } catch (e) { } this.doc = null, this.iframe.parentNode.removeChild(this.iframe), this.iframe = null, CollectGarbage() } }, n.prototype.close = function () { return this.destroy(), t.Transport.XHR.prototype.close.call(this) }, n.check = function () { if ("undefined" != typeof window && ["Active"].concat("Object").join("X") in window) try { var e = new (window[["Active"].concat("Object").join("X")])("htmlfile"); return e && t.Transport.XHR.check() } catch (n) { } return !1 }, n.xdomainCheck = function () { return !1 }, t.transports.push("htmlfile") }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports), function (e, t, n) { function o() { t.Transport.XHR.apply(this, arguments) } function r() { } e["xhr-polling"] = o, t.util.inherit(o, t.Transport.XHR), t.util.merge(o, t.Transport.XHR), o.prototype.name = "xhr-polling", o.prototype.open = function () { var e = this; return t.Transport.XHR.prototype.open.call(e), !1 }, o.prototype.get = function () { function e() { 4 == this.readyState && (this.onreadystatechange = r, 200 == this.status ? (i.onData(this.responseText), i.get()) : i.onClose()) } function t() { this.onload = r, this.onerror = r, i.onData(this.responseText), i.get() } function o() { i.onClose() } if (this.open) { var i = this; this.xhr = this.request(), n.XDomainRequest && this.xhr instanceof XDomainRequest ? (this.xhr.onload = t, this.xhr.onerror = o) : this.xhr.onreadystatechange = e, this.xhr.send(null) } }, o.prototype.onClose = function () { if (t.Transport.XHR.prototype.onClose.call(this), this.xhr) { this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = r; try { this.xhr.abort() } catch (e) { } this.xhr = null } }, o.prototype.ready = function (e, n) { var o = this; t.util.defer(function () { n.call(o) }) }, t.transports.push("xhr-polling") }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), function (e, t, n) { function o(e) { t.Transport["xhr-polling"].apply(this, arguments), this.index = t.j.length; var n = this; t.j.push(function (e) { n._(e) }) } var r = n.document && "MozAppearance" in n.document.documentElement.style; e["jsonp-polling"] = o, t.util.inherit(o, t.Transport["xhr-polling"]), o.prototype.name = "jsonp-polling", o.prototype.post = function (e) { function n() { o(), r.socket.setBuffer(!1) } function o() { r.iframe && r.form.removeChild(r.iframe); try { s = document.createElement('<iframe name="' + r.iframeId + '">') } catch (e) { s = document.createElement("iframe"), s.name = r.iframeId } s.id = r.iframeId, r.form.appendChild(s), r.iframe = s } var r = this, i = t.util.query(this.socket.options.query, "t=" + +new Date + "&i=" + this.index); if (!this.form) { var s, a = document.createElement("form"), c = document.createElement("textarea"), d = this.iframeId = "socketio_iframe_" + this.index; a.className = "socketio", a.style.position = "absolute", a.style.top = "0px", a.style.left = "0px", a.style.display = "none", a.target = d, a.method = "POST", a.setAttribute("accept-charset", "utf-8"), c.name = "d", a.appendChild(c), document.body.appendChild(a), this.form = a, this.area = c } this.form.action = this.prepareUrl() + i, o(), this.area.value = t.JSON.stringify(e); try { this.form.submit() } catch (u) { } this.iframe.attachEvent ? s.onreadystatechange = function () { "complete" == r.iframe.readyState && n() } : this.iframe.onload = n, this.socket.setBuffer(!0) }, o.prototype.get = function () { var e = this, n = document.createElement("script"), o = t.util.query(this.socket.options.query, "t=" + +new Date + "&i=" + this.index); this.script && (this.script.parentNode.removeChild(this.script), this.script = null), n.async = !0, n.src = this.prepareUrl() + o, n.onerror = function () { e.onClose() }; var i = document.getElementsByTagName("script")[0]; i.parentNode.insertBefore(n, i), this.script = n, r && setTimeout(function () { var e = document.createElement("iframe"); document.body.appendChild(e), document.body.removeChild(e) }, 100) }, o.prototype._ = function (e) { return this.onData(e), this.open && this.get(), this }, o.prototype.ready = function (e, n) { var o = this; return r ? void t.util.load(function () { n.call(o) }) : n.call(this) }, o.check = function () { return "document" in n }, o.xdomainCheck = function () { return !0 }, t.transports.push("jsonp-polling") }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this);